<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1424801815195">{:repl-history {:ide [], :local [&quot;(set [1 2 3])&quot; &quot;(concat [1 2 3] [3 4 5])&quot; &quot;(ns gamma.compiler.print\n  (:use gamma.ast)\n  (:use [gamma.ast :only [id?]])\n  (:require [fipp.edn :refer (pprint) :rename {pprint fipp}]\n            fipp.printer))&quot; &quot;1&quot; &quot;(use 'gamma.compiler.print)&quot; &quot;(defn show-ast [y]\n  (let\n    [x\n     (gcompile y)]\n    (fipp.printer/pprint-document\n      (ast-doc2 x :root [:body])\n      {:width 30})))&quot; &quot;(use 'clojure.stacktrace)&quot; &quot;(defn topological-sort [ids db]\n  (let [g1 (into {} (map (fn [id]\n                           [id (filter (:shared (db id)) ids)])\n                         ids))\n        x (println g1)\n        graph\n        (lg/digraph\n          g1)]\n    (reverse (lga/topsort graph))))&quot; &quot;(defn topological-sort [ids db]\n  (let [g1 (into {} (map (fn [id]\n                           [id (filter (:shared (db id)) ids)])\n                         ids))\n        x (println [:result g1])\n        graph\n        (lg/digraph\n          g1)]\n    (reverse (lga/topsort graph))))&quot; &quot;(defn topological-sort [ids db]\n  (let [graph (into {} (map (fn [id]\n                           [id (filter (:shared (db id)) ids)])\n                         ids))]\n    (if (= {} graph) \n      []\n      (reverse (lga/topsort (lg/digraph graph))))))&quot; &quot;(defn topological-sort [ids db]\n  (let [graph (into {} (map (fn [id]\n                           [id (filter (:shared (db id)) ids)])\n                         ids))]\n    (println graph)\n    (if (= {} graph) \n      []\n      (reverse (lga/topsort (lg/digraph graph))))))&quot; &quot;(defn shared-elements [id-mappings source-element source-db]\n  (let [shared (topological-sort\n                 (filter\n                  #(not (id-mappings %))\n                  (get-shared (:shared source-element)))\n                 source-db)]\n    (:elements\n      (reduce\n       (fn [result source-id]\n         (let [new-id (gen-term-id)]\n           {:elements\n                 (conj (:elements result)\n                       {:source-id source-id\n                        :id        new-id\n                        :env       (:env result)})\n            :env (conj (:env result) new-id)}))\n       {:elements [] :env #{}}\n       shared))))&quot; &quot;(show (let [x (g/sin 1)]\n        (g/if true\n          (g/cos (g/if true x x))\n          (g/sin (g/if true x x)))))&quot; &quot;(defn topological-sort [ids db]\n  (println ids)\n  (let [graph (into {} \n                    (map (fn [id]\n                           [id (filter (:shared (db id)) ids)])\n                         ids))]\n \n    (if (= {} graph)\n      []\n      (reverse (lga/topsort (lg/digraph graph))))))&quot; &quot;(clojure.stacktrace/e)&quot; &quot;(:foo {} 1)&quot; &quot;(defn topological-sort [ids db]\n  (println ids)\n  (let [graph (into {}\n                    (map (fn [id]\n                           [id (filter (:shared (db id) {}) ids)])\n                         ids))]\n\n    (if (= {} graph)\n      []\n      (reverse (lga/topsort (lg/digraph graph))))))&quot; &quot;(show (let [x (g/sin 1)]\n        (g/cos (g/if true x x))))&quot; &quot;(show (let [x (g/sin 1)]\n        (g/cos (g/if true x x) x)))&quot; &quot;(defn separate-usages [source-db id-mapping bound-ids]\n  (fn [db location]\n    #_(if (= :sin (:head (get-element db location)))\n      (println [(bound-ids (:id location)) (:id location)]))\n    ;(println (:id location))\n    (let [e (get-element db location)]\n      (println [(:head e) (:id e)]))\n\n    (let [elt (get-element db location)\n          bound-ids (into bound-ids (:env elt))]\n      (if (bound-ids (:id location))\n       [db nil]\n       (let [source-element (source-db (:source-id elt))\n             shared (shared-elements id-mapping source-element source-db)\n             new-id-mapping (into id-mapping (map #(vector (:source-id %) (:id %)) shared))\n             new-bound-ids (into bound-ids (map :id shared))\n             body (body-elements source-element new-id-mapping)]\n\n         [(-&gt; (assoc-attributes db location source-element new-bound-ids)\n              ;(assoc-in [(:id location) :env] new-bound-ids)\n              (merge-elements (location-conj db location :shared) shared)\n              (merge-elements (location-conj db location :body) body))\n          [[:shared (map-path (separate-usages source-db id-mapping bound-ids))]\n           [:body (map-path (separate-usages source-db new-id-mapping new-bound-ids))]]])))))&quot; &quot;(merge #{1} #{2})&quot; &quot;(into #{1} #{2})&quot; &quot;(merge {} nil)&quot; &quot;(defn shared-elements [id-mappings source-element source-db]\n  (let [shared (topological-sort\n                 (filter\n                  #(not (id-mappings %))\n                  (get-shared (:shared source-element)))\n                 source-db)]\n    (:elements\n      (reduce\n       (fn [result source-id]\n         (let [new-id (gen-term-id)]\n           {:elements\n                 (conj (:elements result)\n                       {:source-id source-id\n                        :id        new-id\n                        :env       (:env result)\n                        :id-mapping (:id-mapping result)})\n            :env (conj (:env result) new-id)\n            :id-mapping (assoc (:id-mapping result) source-id new-id)}))\n       {:elements [] :env #{} :id-mapping {}}\n       shared))))&quot; &quot;(defn separate-usages [source-db id-mapping bound-ids]\n  (fn [db location]\n    #_(if (= :sin (:head (get-element db location)))\n      (println [(bound-ids (:id location)) (:id location)]))\n    ;(println (:id location))\n    (let [e (get-element db location)]\n      (println [(:head e) (:id e)]))\n\n    (let [elt (get-element db location)\n          bound-ids (into bound-ids (:env elt))\n          id-mapping (merge id-mapping (:id-mapping elt))]\n      (if (bound-ids (:id location))\n       [db nil]\n       (let [source-element (source-db (:source-id elt))\n             shared (shared-elements id-mapping source-element source-db)\n             new-id-mapping (into id-mapping (map #(vector (:source-id %) (:id %)) shared))\n             new-bound-ids (into bound-ids (map :id shared))\n             body (body-elements source-element new-id-mapping)]\n\n         [(-&gt; (assoc-attributes db location source-element new-bound-ids)\n              ;(assoc-in [(:id location) :env] new-bound-ids)\n              (merge-elements (location-conj db location :shared) shared)\n              (merge-elements (location-conj db location :body) body))\n          [[:shared (map-path (separate-usages source-db id-mapping bound-ids))]\n           [:body (map-path (separate-usages source-db new-id-mapping new-bound-ids))]]])))))&quot; &quot;(defn insert-variables [env]\n  (fn [db location]\n    (let [elt (get-element db location)\n          env (into env (:env elt))]\n      (if (env (:id elt))\n       [(insert-variables-sub db location) nil]\n       (let [new-env (into env (concat\n                                 (:assignments elt)\n                                 (:env elt)))]\n         [\n          db\n          [[:assignments (map-path (insert-variables env))]\n           [:body (map-path (insert-variables new-env))]\n           ]])))))&quot; &quot;(defn insert-variables [env]\n  (fn [db location]\n    (let [elt (get-element db location)\n          env (into env (:env elt))]\n      (println [:env (:id (:id elt)) env])\n      (if (env (:id elt))\n       [(insert-variables-sub db location) nil]\n       (let [new-env (into env (concat\n                                 (:assignments elt)\n                                 (:env elt)))]\n         [\n          db\n          [[:assignments (map-path (insert-variables env))]\n           [:body (map-path (insert-variables new-env))]\n           ]])))))&quot; &quot;(defn insert-variables [env]\n  (fn [db location]\n    (let [elt (get-element db location)\n          env (into env (:env elt))]\n      (println [:env (:id (:id elt)) env location])\n      (if (env (:id elt))\n       [(insert-variables-sub db location) nil]\n       (let [new-env (into env (concat\n                                 (:assignments elt)\n                                 (:env elt)))]\n         [\n          db\n          [[:assignments (map-path (insert-variables env))]\n           [:body (map-path (insert-variables new-env))]\n           ]])))))&quot; &quot;(defn insert-variables [env]\n  (fn [db location]\n    (let [elt (get-element db location)\n         ]\n      (println [:env (:id (:id elt)) (:env elt) location])\n      (if (env (:id elt))\n       [(insert-variables-sub db location) nil]\n       (let [new-env (into env (concat\n                                 (:assignments elt)\n                                 (:env elt)))]\n         [\n          db\n          [[:assignments (map-path (insert-variables env))]\n           [:body (map-path (insert-variables new-env))]\n           ]])))))&quot; &quot;(defn insert-variables [env]\n  (fn [db location]\n    (let [elt (get-element db location)\n         ]\n      (println [:env (:id (:id elt)) (:env elt) env location])\n      (if (env (:id elt))\n       [(insert-variables-sub db location) nil]\n       (let [new-env (into env (concat\n                                 (:assignments elt)\n                                 (:env elt)))]\n         [\n          db\n          [[:assignments (map-path (insert-variables env))]\n           [:body (map-path (insert-variables new-env))]\n           ]])))))&quot; &quot;(defn separate-usages [source-db id-mapping bound-ids]\n  (fn [db location]\n    #_(if (= :sin (:head (get-element db location)))\n      (println [(bound-ids (:id location)) (:id location)]))\n    ;(println (:id location))\n    \n\n    (let [elt (get-element db location)\n          bound-ids (into bound-ids (:env elt))\n          id-mapping (merge id-mapping (:id-mapping elt))]\n      (if (bound-ids (:id location))\n       [db nil]\n       (let [source-element (source-db (:source-id elt))\n             shared (shared-elements id-mapping source-element source-db)\n             new-id-mapping (into id-mapping (map #(vector (:source-id %) (:id %)) shared))\n             new-bound-ids (into bound-ids (map :id shared))\n             body (body-elements source-element new-id-mapping)]\n\n         (let [e (get-element db location)]\n           (println [(:head e) (:id e) shared]))\n\n         [(-&gt; (assoc-attributes db location source-element new-bound-ids)\n              ;(assoc-in [(:id location) :env] new-bound-ids)\n              (merge-elements (location-conj db location :shared) shared)\n              (merge-elements (location-conj db location :body) body))\n          [[:shared (map-path (separate-usages source-db id-mapping bound-ids))]\n           [:body (map-path (separate-usages source-db new-id-mapping new-bound-ids))]]])))))&quot; &quot;(defn body-elements [source-element id-mappings]\n  (mapv\n    (fn [y]\n      (if-let [id (id-mappings y)]\n        {:source-id y :id id }\n        {:source-id y :id (gen-term-id) }))\n    (:body source-element)))&quot; &quot;(show-ast (let [x (g/sin 1)\n            y (g/cos x)]\n        (g/clamp\n          x y y\n          )))&quot; &quot;(show (let [x (g/sin 1)\n            y (g/clamp x x)]\n        (g/clamp\n           x y y\n          )))&quot; &quot;(show (let [x (g/sin 1)\n            y (g/clamp x x)]\n        (g/clamp\n          y x y\n          )))&quot; &quot;(show-ast (let [x (g/sin 1)]\n        (g/block (g/if true x x))))&quot; &quot;(show (let [x (g/sin 1)]\n        (g/block (g/if true x x))))&quot; &quot;(show (let [x (g/sin 1)\n            y (g/clamp x x)]\n        (g/clamp\n          y x\n          )))&quot; &quot;(show (let [x (g/sin 1)]\n        (g/if true x x)))&quot; &quot;(show (let [x (g/sin 1)\n            y (g/cos x)]\n        (g/clamp\n          x y y\n          )))&quot; &quot;(defn topological-sort [ids db]\n  (let [graph (into {}\n                    (map (fn [id]\n                           [id (filter (:shared (db id) {}) ids)])\n                         ids))]\n\n    (if (= {} graph)\n      []\n      (reverse (lga/topsort (lg/digraph graph))))))&quot; &quot;(defn separate-usages [source-db id-mapping bound-ids]\n  (fn [db location]\n    #_(if (= :sin (:head (get-element db location)))\n      (println [(bound-ids (:id location)) (:id location)]))\n    ;(println (:id location))\n\n\n    (let [elt (get-element db location)\n          bound-ids (into bound-ids (:env elt))\n          id-mapping (merge id-mapping (:id-mapping elt))]\n      (if (bound-ids (:id location))\n       [db nil]\n       (let [source-element (source-db (:source-id elt))\n             shared (shared-elements id-mapping source-element source-db)\n             new-id-mapping (into id-mapping (map #(vector (:source-id %) (:id %)) shared))\n             new-bound-ids (into bound-ids (map :id shared))\n             body (body-elements source-element new-id-mapping)]\n\n        \n\n         [(-&gt; (assoc-attributes db location source-element new-bound-ids)\n              ;(assoc-in [(:id location) :env] new-bound-ids)\n              (merge-elements (location-conj db location :shared) shared)\n              (merge-elements (location-conj db location :body) body))\n          [[:shared (map-path (separate-usages source-db id-mapping bound-ids))]\n           [:body (map-path (separate-usages source-db new-id-mapping new-bound-ids))]]])))))&quot; &quot;(defn insert-variables [env]\n  (fn [db location]\n    (let [elt (get-element db location)\n         ]\n      (if (env (:id elt))\n       [(insert-variables-sub db location) nil]\n       (let [new-env (into env (concat\n                                 (:assignments elt)\n                                 (:env elt)))]\n         [\n          db\n          [[:assignments (map-path (insert-variables env))]\n           [:body (map-path (insert-variables new-env))]\n           ]])))))&quot; &quot;(let [x 1] \n  {:a x :b x})&quot; &quot;(let [x (g/sin 1)]\n  (g/clamp x x))&quot; &quot;(show (let [x (g/sin 1)]\n        (g/clamp x x)))&quot; &quot;(g/vec3 1)&quot; &quot;(map g/sin [1 2 3])&quot; &quot;(show \n  (apply g/clamp (map g/sin [1 2 3])))&quot; &quot;(second [1 2 3])&quot; &quot;(group-by first [[1 2] [1 3]])&quot; &quot;(defn infer-parameterized-type [rule args]\n  (let [prule (:parameter rule)\n        input-types (:input rule)]\n    (if (not= (count input-types) (count args))\n      :fail\n      (loop [input args\n             expected input-types\n             parameter nil]\n        (if (empty? input-types)\n          (if (prule (:output rule)) parameter (:output rule))\n          (let [i (first input) e (first expected) p (prule e)]\n            (if p\n              ;; expecting a parameterized type\n              (if parameter\n                ;; already have determined the concrete parameter\n                (if (= parameter i)\n                  (recur (next input) (next expected) parameter)\n                  :fail)\n                ;; need to determine concrete parameter\n                (if (p i)\n                  ;; type is within the parameterized range\n                  (recur (next input) (next expected) (p i))\n                  :fail))\n              ;; not expected a parameterized type\n              (if (= i e)\n                (recur (next input) (next expected) parameter)\n                :fail))))))))&quot; &quot;(infer-parameterized-type {:parameter {:T #{:vec3 :vec4}}\n                             :input [:T :bool :T]} \n                            [:vec4 :bool :vec4])&quot; &quot;4&quot; &quot;(defn infer-parameterized-type [rule args]\n  (let [prule (:parameter rule)\n        input-types (:input rule)]\n    (if (not= (count input-types) (count args))\n      :fail\n      (loop [input args\n             expected input-types\n             parameter nil]\n        (if (empty? input-types)\n          parameter                                         ;(if (prule (:output rule)) parameter (:output rule))\n          (let [i (first input) e (first expected) p (prule e)]\n            (if p\n              ;; expecting a parameterized type\n              (if parameter\n                ;; already have determined the concrete parameter\n                (if (= parameter i)\n                  (recur (next input) (next expected) parameter)\n                  :fail)\n                ;; need to determine concrete parameter\n                (if (p i)\n                  ;; type is within the parameterized range\n                  (recur (next input) (next expected) (p i))\n                  :fail))\n              ;; not expected a parameterized type\n              (if (= i e)\n                (recur (next input) (next expected) parameter)\n                :fail))))))))&quot; &quot;(defn infer-parameterized-type [rule args]\n  (let [prule (:parameter rule)\n        input-types (:input rule)]\n    (if (not= (count input-types) (count args))\n      :fail\n      (loop [input args\n             expected input-types\n             parameter nil]\n        (if (empty? input-types)\n          parameter\n          (let [i (first input) e (first expected) p (prule e)]\n            (if p\n              ;; expecting a parameterized type\n              (if parameter\n                ;; already have determined the concrete parameter\n                (if (= parameter i)\n                  (recur (next input) (next expected) parameter)\n                  :fail)\n                ;; need to determine concrete parameter\n                (if (p i)\n                  ;; type is within the parameterized range\n                  (recur (next input) (next expected) (p i))\n                  :fail))\n              ;; not expected a parameterized type\n              (if (= i e)\n                (recur (next input) (next expected) parameter)\n                :fail))))))))&quot; &quot;(defn infer-parameterized-type [rule args]\n  (let [prule (:parameter rule)\n        input-types (:input rule)]\n    (if (not= (count input-types) (count args))\n      :fail\n      (loop [input args\n             expected input-types\n             parameter nil]\n        (println [input expected parameter])\n        (if (empty? input-types)\n          parameter\n          (let [i (first input) e (first expected) p (prule e)]\n            (if p\n              ;; expecting a parameterized type\n              (if parameter\n                ;; already have determined the concrete parameter\n                (if (= parameter i)\n                  (recur (next input) (next expected) parameter)\n                  :fail)\n                ;; need to determine concrete parameter\n                (if (p i)\n                  ;; type is within the parameterized range\n                  (recur (next input) (next expected) (p i))\n                  :fail))\n              ;; not expected a parameterized type\n              (if (= i e)\n                (recur (next input) (next expected) parameter)\n                :fail))))))))&quot; &quot;(defn infer-parameterized-type [rule args]\n  (let [prule (:parameter rule)\n        input-types (:input rule)]\n    (if (not= (count input-types) (count args))\n      :fail\n      (loop [input args\n             expected input-types\n             parameter nil]\n        (println [input expected parameter])\n        (if (empty? expected)\n          parameter\n          (let [i (first input) e (first expected) p (prule e)]\n            (if p\n              ;; expecting a parameterized type\n              (if parameter\n                ;; already have determined the concrete parameter\n                (if (= parameter i)\n                  (recur (next input) (next expected) parameter)\n                  :fail)\n                ;; need to determine concrete parameter\n                (if (p i)\n                  ;; type is within the parameterized range\n                  (recur (next input) (next expected) (p i))\n                  :fail))\n              ;; not expected a parameterized type\n              (if (= i e)\n                (recur (next input) (next expected) parameter)\n                :fail))))))))&quot; &quot;(defn infer-parameterized-type [rule args]\n  (let [prule (:parameter rule)\n        input-types (:input rule)]\n    (if (not= (count input-types) (count args))\n      :fail\n      (loop [input args\n             expected input-types\n             parameter nil]\n        (println [input expected parameter])\n        (if (empty? expected)\n          (if (prule (:output rule)) parameter (:output rule))\n          (let [i (first input) e (first expected) p (prule e)]\n            (if p\n              ;; expecting a parameterized type\n              (if parameter\n                ;; already have determined the concrete parameter\n                (if (= parameter i)\n                  (recur (next input) (next expected) parameter)\n                  :fail)\n                ;; need to determine concrete parameter\n                (if (p i)\n                  ;; type is within the parameterized range\n                  (recur (next input) (next expected) (p i))\n                  :fail))\n              ;; not expected a parameterized type\n              (if (= i e)\n                (recur (next input) (next expected) parameter)\n                :fail))))))))&quot; &quot;(infer-parameterized-type {:parameter {:T #{:vec3 :vec4}}\n                           :input [:T :bool :T]}\n                          [:vec4 :bool :vec4])&quot; &quot;(infer-parameterized-type {:parameter {:T #{:vec3 :vec4}}\n                           :input [:T :bool :T] :output :vec2}\n                          [:vec4 :bool :vec4])&quot; &quot;(infer-parameterized-type {:parameter {:T #{:vec3 :vec4}}\n                           :input [:T :bool :T] :output :T}\n                          [:vec4 :bool :vec4])&quot; &quot;(def standard-functions\n  (group-by :name\n   (map\n     (fn [x]\n       {:name      (x 1) :input (x 2) :output (x 0)\n        :parameter {:T #{:float :vec2 :vec3 :vec4}}})\n     [[:T :radians [:T :degrees]]\n      [:T :degrees [:T :radians]]\n      [:T :sin [:T :angle]]\n      [:T :cos [:T :angle]]\n      [:T :tan [:T :angle]]\n      [:T :asin [:T :x]]\n      [:T :acos [:T :x]]\n      [:T :atan [:T :y :T :x]]\n      [:T :atan [:T :y_over_x]]\n\n      [:T :power [:T :x :T :y]]\n      [:T :exp [:T :x]]\n      [:T :log [:T :x]]\n      [:T :exp2 [:T :x]]\n      [:T :log2 [:T :x]]\n      [:T :sqrt [:T :x]]\n      [:T :inversesqrt [:T :x]]\n\n      [:T :abs [:T :x]]\n      [:T :sign [:T :x]]\n      [:T :floor [:T :x]]\n      [:T :ceil [:T :x]]\n      [:T :fract [:T :x]]\n      [:T :mod [:T :x :T :y]]\n      [:T :max [:T :x :float :y]]\n      [:T :clamp [:T :x :T :minVal :T :maxVal]]\n      [:T :clamp [:T :x :float :minVal :float :maxVal]]\n      [:T :step [:T :edge :T :x]]\n      [:T :step [:float :edge :T :x]]\n      [:T :smoothstep [:T :edge0 :T :edge1 :T :x]]\n      [:T :smoothstep [:float :edge0 :float :edge1 :T :x]]\n\n      [:float :length [:T :x]]\n      [:float :distance [:T :p0 :T :p1]]\n      [:float :dot [:T :x :T :y]]\n      [:vec3 :cross [:vec3 :x :vec3 :y]]\n      [:T :normalize [:T :x]]\n      [:T :faceforward [:T :N :T :I :T :Nref]]\n      [:T :reflect [:T :I :T :N]]\n      [:T :refract [:T :I :T :N :float :eta]]\n\n      [:vec4 :texture2DLod [:sampler2D :sampler :vec2 :coord :float :lod]]\n      [:vec4 :texture2DProjLod [:sampler2D :sampler :vec3 :coord :float :lod]]\n      [:vec4 :texture2DProjLod [:sampler2D :sampler :vec4 :coord :float :lod]]\n      [:vec4 :textureCubeLod [:sampler2D :sampler :vec4 :coord :float :lod]]\n      ;; available only in fragement shaders\n      [:vec4 :texture2D [:sampler2D :sampler :vec2 :coord :float :bias]]\n      [:vec4 :texture2DProj [:sampler2D :sampler :vec3 :coord :float :bias]]\n      [:vec4 :texture2DProj [:sampler2D :sampler :vec4 :coord :float :bias]]\n      [:vec4 :textureCube [:samplerCube :sampler :vec3 :coord :float :bias]]\n      ;; available in both\n      [:vec4 :texture2D [:sampler2D :sampler :vec2 :coord]]\n      [:vec4 :texture2DProj [:sampler2D :sampler :vec3 :coord]]\n      [:vec4 :texture2DProj [:sampler2D :vec4 :coord]]\n      [:vec4 :textureCube [:samplerCube :sampler :vec3 :coord]]\n\n      ])))&quot; &quot;(defn build-standard-function-term [name specs args]\n  (let [t (apply term name args)]\n    (if-let [result\n            (first\n              (filter #(not= :fail %)\n                      (map #(infer-parameterized-type % (map :type (:body t)))\n                           specs)))]\n     (assoc t :type result)\n     (throw (Exception. \&quot;Wrong type signature\&quot;)))))&quot; &quot;(term :foo 1 2)&quot; &quot;(use 'gamma.ast)&quot; &quot;(use 'gamma.ast :reload) &quot; &quot;(in-ns 'gamma.ast)&quot; &quot;(literal 1)&quot; &quot;(literal 1.0)&quot; &quot;(defn define-standard-function [n specs]\n  `(defn ~(symbol (name n)) [&amp; body#]\n     (build-standard-function-term name specs body#)))&quot; &quot;(defn define-standard-function [n specs]\n  `(defn ~(symbol (name n)) [&amp; body#]\n     (build-standard-function-term n specs body#)))&quot; &quot;(defn define-standard-function [n specs]\n  `(defn ~(symbol (name n)) [&amp; body#]\n     (build-standard-function-term ~n ~specs body#)))&quot; &quot;(define-standard-function :abs (:abs standard-functions))\n&quot; &quot;(take-nth 2 [1 2 3 4])&quot; &quot;(def standard-functions\n  (group-by :name\n   (map\n     (fn [x]\n       {:name      (x 1) :input (take-nth 2 (x 2)) :output (x 0)\n        :parameter {:T #{:float :vec2 :vec3 :vec4}}})\n     [[:T :radians [:T :degrees]]\n      [:T :degrees [:T :radians]]\n      [:T :sin [:T :angle]]\n      [:T :cos [:T :angle]]\n      [:T :tan [:T :angle]]\n      [:T :asin [:T :x]]\n      [:T :acos [:T :x]]\n      [:T :atan [:T :y :T :x]]\n      [:T :atan [:T :y_over_x]]\n\n      [:T :power [:T :x :T :y]]\n      [:T :exp [:T :x]]\n      [:T :log [:T :x]]\n      [:T :exp2 [:T :x]]\n      [:T :log2 [:T :x]]\n      [:T :sqrt [:T :x]]\n      [:T :inversesqrt [:T :x]]\n\n      [:T :abs [:T :x]]\n      [:T :sign [:T :x]]\n      [:T :floor [:T :x]]\n      [:T :ceil [:T :x]]\n      [:T :fract [:T :x]]\n      [:T :mod [:T :x :T :y]]\n      [:T :max [:T :x :float :y]]\n      [:T :clamp [:T :x :T :minVal :T :maxVal]]\n      [:T :clamp [:T :x :float :minVal :float :maxVal]]\n      [:T :step [:T :edge :T :x]]\n      [:T :step [:float :edge :T :x]]\n      [:T :smoothstep [:T :edge0 :T :edge1 :T :x]]\n      [:T :smoothstep [:float :edge0 :float :edge1 :T :x]]\n\n      [:float :length [:T :x]]\n      [:float :distance [:T :p0 :T :p1]]\n      [:float :dot [:T :x :T :y]]\n      [:vec3 :cross [:vec3 :x :vec3 :y]]\n      [:T :normalize [:T :x]]\n      [:T :faceforward [:T :N :T :I :T :Nref]]\n      [:T :reflect [:T :I :T :N]]\n      [:T :refract [:T :I :T :N :float :eta]]\n\n      [:vec4 :texture2DLod [:sampler2D :sampler :vec2 :coord :float :lod]]\n      [:vec4 :texture2DProjLod [:sampler2D :sampler :vec3 :coord :float :lod]]\n      [:vec4 :texture2DProjLod [:sampler2D :sampler :vec4 :coord :float :lod]]\n      [:vec4 :textureCubeLod [:sampler2D :sampler :vec4 :coord :float :lod]]\n      ;; available only in fragement shaders\n      [:vec4 :texture2D [:sampler2D :sampler :vec2 :coord :float :bias]]\n      [:vec4 :texture2DProj [:sampler2D :sampler :vec3 :coord :float :bias]]\n      [:vec4 :texture2DProj [:sampler2D :sampler :vec4 :coord :float :bias]]\n      [:vec4 :textureCube [:samplerCube :sampler :vec3 :coord :float :bias]]\n      ;; available in both\n      [:vec4 :texture2D [:sampler2D :sampler :vec2 :coord]]\n      [:vec4 :texture2DProj [:sampler2D :sampler :vec3 :coord]]\n      [:vec4 :texture2DProj [:sampler2D :vec4 :coord]]\n      [:vec4 :textureCube [:samplerCube :sampler :vec3 :coord]]\n\n      ])))&quot; &quot;(eval (define-standard-function :abs (:abs standard-functions))\n      )&quot; &quot;(standard-functions :abs)&quot; &quot;(infer-parameterized-type (first (standard-functions :abs)) [:float])&quot; &quot;(apply term :abs [1])&quot; &quot;(map :type (:body (apply term :abs [1])))&quot; &quot;(map :type (:body (apply term :abs [1.0])))&quot; &quot;(defn build-standard-function-term [name specs args]\n  (let [t (apply term name args)]\n    (let [result\n            (first\n              (filter #(not= :fail %)\n                      (map #(infer-parameterized-type % (map :type (:body t)))\n                           specs)))]\n      (assoc t :type result)\n     )))&quot; &quot;(define-standard-function :abs (:abs standard-functions))&quot; &quot;(gamma.ast/build-standard-function-term :abs [{:name :abs, :input (:T), :output :T, :parameter {:T #{:vec3 :float :vec4 :vec2}}}] \n                                        [1.0])&quot; &quot;(gamma.ast/build-standard-function-term :abs \n                                        [{:name :abs, :input '(:T), :output :T, :parameter {:T #{:vec3 :float :vec4 :vec2}}}] \n                                        [1.0])&quot; &quot;(def standard-functions\n  (group-by :name\n   (map\n     (fn [x]\n       {:name      (x 1) :input (vec (take-nth 2 (x 2))) :output (x 0)\n        :parameter {:T #{:float :vec2 :vec3 :vec4}}})\n     [[:T :radians [:T :degrees]]\n      [:T :degrees [:T :radians]]\n      [:T :sin [:T :angle]]\n      [:T :cos [:T :angle]]\n      [:T :tan [:T :angle]]\n      [:T :asin [:T :x]]\n      [:T :acos [:T :x]]\n      [:T :atan [:T :y :T :x]]\n      [:T :atan [:T :y_over_x]]\n\n      [:T :power [:T :x :T :y]]\n      [:T :exp [:T :x]]\n      [:T :log [:T :x]]\n      [:T :exp2 [:T :x]]\n      [:T :log2 [:T :x]]\n      [:T :sqrt [:T :x]]\n      [:T :inversesqrt [:T :x]]\n\n      [:T :abs [:T :x]]\n      [:T :sign [:T :x]]\n      [:T :floor [:T :x]]\n      [:T :ceil [:T :x]]\n      [:T :fract [:T :x]]\n      [:T :mod [:T :x :T :y]]\n      [:T :max [:T :x :float :y]]\n      [:T :clamp [:T :x :T :minVal :T :maxVal]]\n      [:T :clamp [:T :x :float :minVal :float :maxVal]]\n      [:T :step [:T :edge :T :x]]\n      [:T :step [:float :edge :T :x]]\n      [:T :smoothstep [:T :edge0 :T :edge1 :T :x]]\n      [:T :smoothstep [:float :edge0 :float :edge1 :T :x]]\n\n      [:float :length [:T :x]]\n      [:float :distance [:T :p0 :T :p1]]\n      [:float :dot [:T :x :T :y]]\n      [:vec3 :cross [:vec3 :x :vec3 :y]]\n      [:T :normalize [:T :x]]\n      [:T :faceforward [:T :N :T :I :T :Nref]]\n      [:T :reflect [:T :I :T :N]]\n      [:T :refract [:T :I :T :N :float :eta]]\n\n      [:vec4 :texture2DLod [:sampler2D :sampler :vec2 :coord :float :lod]]\n      [:vec4 :texture2DProjLod [:sampler2D :sampler :vec3 :coord :float :lod]]\n      [:vec4 :texture2DProjLod [:sampler2D :sampler :vec4 :coord :float :lod]]\n      [:vec4 :textureCubeLod [:sampler2D :sampler :vec4 :coord :float :lod]]\n      ;; available only in fragement shaders\n      [:vec4 :texture2D [:sampler2D :sampler :vec2 :coord :float :bias]]\n      [:vec4 :texture2DProj [:sampler2D :sampler :vec3 :coord :float :bias]]\n      [:vec4 :texture2DProj [:sampler2D :sampler :vec4 :coord :float :bias]]\n      [:vec4 :textureCube [:samplerCube :sampler :vec3 :coord :float :bias]]\n      ;; available in both\n      [:vec4 :texture2D [:sampler2D :sampler :vec2 :coord]]\n      [:vec4 :texture2DProj [:sampler2D :sampler :vec3 :coord]]\n      [:vec4 :texture2DProj [:sampler2D :vec4 :coord]]\n      [:vec4 :textureCube [:samplerCube :sampler :vec3 :coord]]\n\n      ])))&quot; &quot;(eval (define-standard-function :abs (:abs standard-functions)))&quot; &quot;(abs 1 2)&quot; &quot;(str [\&quot; \&quot; \&quot;,\&quot; a])&quot; &quot;(str [\&quot; \&quot; \&quot;,\&quot; \&quot;1\&quot;])&quot; &quot;(defn build-standard-function-term [name specs args]\n  (let [t (apply term name args)]\n    (if-let [result\n            (first\n              (filter #(not= :fail %)\n                      (map #(infer-parameterized-type % (map :type (:body t)))\n                           specs)))]\n      (assoc t :type result)\n      (throw (Exception. (apply pr-str \&quot;Wrong argument types for term \&quot; (clojure.core/name name)\n                              \&quot;: \&quot; (interpose \&quot; ,\&quot; (map :type args)))))\n     )))&quot; &quot;(abs 1.0)&quot; &quot;(defn build-standard-function-term [name specs args]\n  (let [t (apply term name args)]\n    (if-let [result\n            (first\n              (filter #(not= :fail %)\n                      (map #(infer-parameterized-type % (map :type (:body t)))\n                           specs)))]\n      (assoc t :type result)\n      (throw (Exception. (apply str \&quot;Wrong argument types for term \&quot; (clojure.core/name name)\n                              \&quot;: \&quot; (interpose \&quot; ,\&quot; (map :type args)))))\n     )))&quot; &quot;(defn build-standard-function-term [name specs args]\n  (let [t (apply term name args)]\n    (if-let [result\n            (first\n              (filter #(not= :fail %)\n                      (map #(infer-parameterized-type % (map :type (:body t)))\n                           specs)))]\n      (assoc t :type result)\n      (throw (Exception. (apply str \&quot;Wrong argument types for term \&quot; (clojure.core/name name)\n                              \&quot;: \&quot; (interpose \&quot; ,\&quot; (map :type (:body t))))))\n     )))&quot; &quot;(abs 1)&quot; &quot;(show (let [x (g/sin 1)\n            y (g/if true x x)]\n            (g/sin\n              (g/clamp\n               (g/if true\n                 (g/cos y)\n                 (g/sin y) ) y\n               ) x)))&quot; &quot;(defn show [x]\n  (let [y (gcompile x)]\n    (fipp.printer/pprint-document\n      (emit y (y :root))\n      {:width 80})))&quot; &quot;(defn gcompile [input]\n  (-&gt;\n    (transform\n      {:root {:source-id :root :id :root}}\n      (separate-usages\n        (bubble-terms (flatten-ast input)) {} #{}))\n    (transform (lift-assignments :root))\n    (transform (insert-variables #{}))\n    (transform (insert-assignments))\n    (transform (move-assignments))\n    )\n  )&quot; &quot;(or 1 2)&quot; &quot;(ns gamma.examples\n  (:require\n    [gamma.api :as g]\n\n    gamma.emit.function\n    gamma.emit.operator\n    gamma.emit.statement\n    gamma.emit.tag\n    [gamma.ast :as ast])\n  (:use\n    [gamma.emit.emit :only [emit]]\n    [gamma.compiler.print :only [ast-doc2 ast-doc3]]\n    [gamma.compiler.flatten-ast :only [flatten-ast]]\n    [gamma.compiler.bubble-term :only [bubble-terms]]\n    [gamma.compiler.insert-assignments :only [insert-assignments]]\n    [gamma.compiler.lift-assignments :only [lift-assignments]]\n    [gamma.compiler.separate-usages :only [separate-usages]]\n    [gamma.compiler.insert-variables :only [insert-variables]]\n    [gamma.compiler.move-assignments :only [move-assignments]]\n    [gamma.compiler.core :only [transform]]))&quot;], :remote []}}</component>
</project>

