<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1425851697596">{:repl-history {:ide [], :local [&quot;(eval (define-standard-function :abs (:abs standard-functions))\n      )&quot; &quot;(standard-functions :abs)&quot; &quot;(infer-parameterized-type (first (standard-functions :abs)) [:float])&quot; &quot;(apply term :abs [1])&quot; &quot;(map :type (:body (apply term :abs [1])))&quot; &quot;(map :type (:body (apply term :abs [1.0])))&quot; &quot;(defn build-standard-function-term [name specs args]\n  (let [t (apply term name args)]\n    (let [result\n            (first\n              (filter #(not= :fail %)\n                      (map #(infer-parameterized-type % (map :type (:body t)))\n                           specs)))]\n      (assoc t :type result)\n     )))&quot; &quot;(define-standard-function :abs (:abs standard-functions))&quot; &quot;(gamma.ast/build-standard-function-term :abs [{:name :abs, :input (:T), :output :T, :parameter {:T #{:vec3 :float :vec4 :vec2}}}] \n                                        [1.0])&quot; &quot;(gamma.ast/build-standard-function-term :abs \n                                        [{:name :abs, :input '(:T), :output :T, :parameter {:T #{:vec3 :float :vec4 :vec2}}}] \n                                        [1.0])&quot; &quot;(def standard-functions\n  (group-by :name\n   (map\n     (fn [x]\n       {:name      (x 1) :input (vec (take-nth 2 (x 2))) :output (x 0)\n        :parameter {:T #{:float :vec2 :vec3 :vec4}}})\n     [[:T :radians [:T :degrees]]\n      [:T :degrees [:T :radians]]\n      [:T :sin [:T :angle]]\n      [:T :cos [:T :angle]]\n      [:T :tan [:T :angle]]\n      [:T :asin [:T :x]]\n      [:T :acos [:T :x]]\n      [:T :atan [:T :y :T :x]]\n      [:T :atan [:T :y_over_x]]\n\n      [:T :power [:T :x :T :y]]\n      [:T :exp [:T :x]]\n      [:T :log [:T :x]]\n      [:T :exp2 [:T :x]]\n      [:T :log2 [:T :x]]\n      [:T :sqrt [:T :x]]\n      [:T :inversesqrt [:T :x]]\n\n      [:T :abs [:T :x]]\n      [:T :sign [:T :x]]\n      [:T :floor [:T :x]]\n      [:T :ceil [:T :x]]\n      [:T :fract [:T :x]]\n      [:T :mod [:T :x :T :y]]\n      [:T :max [:T :x :float :y]]\n      [:T :clamp [:T :x :T :minVal :T :maxVal]]\n      [:T :clamp [:T :x :float :minVal :float :maxVal]]\n      [:T :step [:T :edge :T :x]]\n      [:T :step [:float :edge :T :x]]\n      [:T :smoothstep [:T :edge0 :T :edge1 :T :x]]\n      [:T :smoothstep [:float :edge0 :float :edge1 :T :x]]\n\n      [:float :length [:T :x]]\n      [:float :distance [:T :p0 :T :p1]]\n      [:float :dot [:T :x :T :y]]\n      [:vec3 :cross [:vec3 :x :vec3 :y]]\n      [:T :normalize [:T :x]]\n      [:T :faceforward [:T :N :T :I :T :Nref]]\n      [:T :reflect [:T :I :T :N]]\n      [:T :refract [:T :I :T :N :float :eta]]\n\n      [:vec4 :texture2DLod [:sampler2D :sampler :vec2 :coord :float :lod]]\n      [:vec4 :texture2DProjLod [:sampler2D :sampler :vec3 :coord :float :lod]]\n      [:vec4 :texture2DProjLod [:sampler2D :sampler :vec4 :coord :float :lod]]\n      [:vec4 :textureCubeLod [:sampler2D :sampler :vec4 :coord :float :lod]]\n      ;; available only in fragement shaders\n      [:vec4 :texture2D [:sampler2D :sampler :vec2 :coord :float :bias]]\n      [:vec4 :texture2DProj [:sampler2D :sampler :vec3 :coord :float :bias]]\n      [:vec4 :texture2DProj [:sampler2D :sampler :vec4 :coord :float :bias]]\n      [:vec4 :textureCube [:samplerCube :sampler :vec3 :coord :float :bias]]\n      ;; available in both\n      [:vec4 :texture2D [:sampler2D :sampler :vec2 :coord]]\n      [:vec4 :texture2DProj [:sampler2D :sampler :vec3 :coord]]\n      [:vec4 :texture2DProj [:sampler2D :vec4 :coord]]\n      [:vec4 :textureCube [:samplerCube :sampler :vec3 :coord]]\n\n      ])))&quot; &quot;(eval (define-standard-function :abs (:abs standard-functions)))&quot; &quot;(abs 1 2)&quot; &quot;(str [\&quot; \&quot; \&quot;,\&quot; a])&quot; &quot;(str [\&quot; \&quot; \&quot;,\&quot; \&quot;1\&quot;])&quot; &quot;(defn build-standard-function-term [name specs args]\n  (let [t (apply term name args)]\n    (if-let [result\n            (first\n              (filter #(not= :fail %)\n                      (map #(infer-parameterized-type % (map :type (:body t)))\n                           specs)))]\n      (assoc t :type result)\n      (throw (Exception. (apply pr-str \&quot;Wrong argument types for term \&quot; (clojure.core/name name)\n                              \&quot;: \&quot; (interpose \&quot; ,\&quot; (map :type args)))))\n     )))&quot; &quot;(abs 1.0)&quot; &quot;(defn build-standard-function-term [name specs args]\n  (let [t (apply term name args)]\n    (if-let [result\n            (first\n              (filter #(not= :fail %)\n                      (map #(infer-parameterized-type % (map :type (:body t)))\n                           specs)))]\n      (assoc t :type result)\n      (throw (Exception. (apply str \&quot;Wrong argument types for term \&quot; (clojure.core/name name)\n                              \&quot;: \&quot; (interpose \&quot; ,\&quot; (map :type args)))))\n     )))&quot; &quot;(defn build-standard-function-term [name specs args]\n  (let [t (apply term name args)]\n    (if-let [result\n            (first\n              (filter #(not= :fail %)\n                      (map #(infer-parameterized-type % (map :type (:body t)))\n                           specs)))]\n      (assoc t :type result)\n      (throw (Exception. (apply str \&quot;Wrong argument types for term \&quot; (clojure.core/name name)\n                              \&quot;: \&quot; (interpose \&quot; ,\&quot; (map :type (:body t))))))\n     )))&quot; &quot;(abs 1)&quot; &quot;(or 1 2)&quot; &quot;(ns gamma.examples\n  (:require\n    [gamma.api :as g]\n\n    gamma.emit.function\n    gamma.emit.operator\n    gamma.emit.statement\n    gamma.emit.tag\n    [gamma.ast :as ast])\n  (:use\n    [gamma.emit.emit :only [emit]]\n    [gamma.compiler.print :only [ast-doc2 ast-doc3]]\n    [gamma.compiler.flatten-ast :only [flatten-ast]]\n    [gamma.compiler.bubble-term :only [bubble-terms]]\n    [gamma.compiler.insert-assignments :only [insert-assignments]]\n    [gamma.compiler.lift-assignments :only [lift-assignments]]\n    [gamma.compiler.separate-usages :only [separate-usages]]\n    [gamma.compiler.insert-variables :only [insert-variables]]\n    [gamma.compiler.move-assignments :only [move-assignments]]\n    [gamma.compiler.core :only [transform]]))&quot; &quot;(defn show-ast [y]\n  (let\n    [x\n     (gcompile y)]\n    (fipp.printer/pprint-document\n      (ast-doc2 x :root [:body])\n      {:width 30})))&quot; &quot;(defn show [x]\n  (let [y (gcompile x)]\n    (fipp.printer/pprint-document\n      (emit y (y :root))\n      {:width 80})))&quot; &quot;(show (let [x (g/sin 1)\n            y (g/if true x x)]\n            (g/sin\n              (g/clamp\n               (g/if true\n                 (g/cos y)\n                 (g/sin y) ) y\n               ) x)))&quot; &quot;(show (let [x (g/sin 1.0)\n            y (g/if true x x)]\n            (g/sin\n              (g/clamp\n               (g/if true\n                 (g/cos y)\n                 (g/sin y) ) y\n               ) x)))&quot; &quot;(show (let [x (g/sin 1.0)\n            y (g/if true x x)]\n            (g/sin\n              (g/clamp\n               (g/if true\n                 (g/cos y)\n                 (g/sin y) )y x\n               ) x)))&quot; &quot;gamma.ast/functions&quot; &quot;(def functions\n  (into #{}\n        (concat\n          (map :name vector-relational-functions)\n          (map :name matrix-functions)\n          (map first standard-functions)))\n\n  )&quot; &quot;(gamma.ast/functions :sin)&quot; &quot;(gcompile\n  (let [x (g/sin 1.0)\n        y (g/if true x x)]\n    (g/sin\n      (g/clamp\n        (g/if true\n          (g/cos y)\n          (g/sin y) )y x\n        ) )))&quot; &quot;(require 'gamma.compiler.insert-declarations)&quot; &quot;gamma.compiler.insert-declarations/variables&quot; &quot;(ns gamma.compiler.insert-declarations\n  (:use [gamma.ast :only [id? gen-term-id]])\n  (:use [gamma.compiler.common :only [get-element map-path assoc-in-location assoc-elements]])\n  (use [gamma.compiler.core :only [transform]]))&quot; &quot;(defn walk [db pre]\n  (transform\n    db\n    (fn walk-fn [db path]\n      [(pre db path) [[:body (map-path walk-fn)]]])))&quot; &quot;(defn variables [db]\n  (let [a (atom #{})]\n    (walk db (fn [db location]\n               (let [e (get-element db location)]\n                 (if (= :literal (:head e))\n                   (if (= :variable (:tag (:value e)))\n                     (swap! a conj (:value e)))))\n               db))))&quot; &quot;(defn variables [db]\n  (let [a (atom #{})]\n    (walk db (fn [db location]\n               (let [e (get-element db location)]\n                 (if (= :literal (:head e))\n                   (if (= :variable (:tag (:value e)))\n                     (swap! a conj (:value e)))))\n               db))\n    @a\n    ))&quot; &quot;(gamma.compiler.insert-declarations/variables (gcompile\n   (let [x (g/sin 1.0)\n         y (g/if true x x)]\n     (g/sin\n       (g/clamp\n         (g/if true\n           (g/cos y)\n           (g/sin y)) y x\n         )))))&quot; &quot;(in-ns 'gamma.examples)&quot; &quot;(g/sin 1.0)&quot; &quot;(:type (g/sin 1.0))&quot; &quot;(let [x (g/sin 1.0)] (g/if true x x))&quot; &quot;(:type (let [x (g/sin 1.0)] (g/if true x x)))&quot; &quot;(gamma.compiler.insert-declarations/variables\n  (gcompile\n    (let [x (g/sin 1.0)\n          y (g/if true x x)]\n      (g/sin\n        (g/clamp\n          (g/if true\n            (g/cos y)\n            (g/sin y)) y x\n          )))))&quot; &quot;(defn insert-assignment [db location target-id]\n  (let [set-id (gen-term-id) var-id (gen-term-id)\n        this-id (:id location) parent-loc (:parent location)]\n    ;(println [this-id ])\n    (-&gt; db\n        (assoc-elements [{:id set-id :head :set :body [var-id this-id]}\n                         {:id var-id :head :literal\n                          :value {:tag :variable :id target-id\n                                  :type (:type (db target-id))}}])\n        (assoc-in-location parent-loc set-id))))&quot; &quot;(show (let [x (g/sin 1.0)\n            y (g/if true x x)]\n            (g/sin\n              (g/clamp\n               (g/if true\n                 (g/cos y)\n                 (g/sin y) )y x\n               ) )))&quot; &quot;(show-ast (let [x (g/sin 1.0)\n            y (g/if true x x)]\n            (g/sin\n              (g/clamp\n               (g/if true\n                 (g/cos y)\n                 (g/sin y) )y x\n               ) )))&quot; &quot;(show (let [x (g/sin 1.0)\n                z (g/cos 1.0)\n                y (g/if true x z)\n                ]\n            (g/sin\n              (g/clamp \n                z y\n                (g/clamp\n                 (g/if true\n                   (g/cos z)\n                   (g/sin y)) y x\n                 )) )))&quot; &quot;(defn insert-assignment [db location target-id]\n  (let [set-id (gen-term-id) var-id (gen-term-id)\n        this-id (:id location) parent-loc (:parent location)]\n    ;(println [this-id ])\n    (-&gt; db\n        (assoc-elements [{:id set-id :head :set :body [var-id this-id]}\n                         {:id var-id :head :literal\n                          :value {:tag :variable :id target-id\n                                  :type (:type (get-element db location))}}])\n        (assoc-in-location parent-loc set-id))))&quot; &quot;(defn insert-assignments []\n  (fn [db location ]\n    (let [e (get-element db location)]\n      (if (= :block (:head e))\n        [db\n         [[:assignments\n           (let [x (map-indexed\n                     (fn [i y] [i (insert-assignments-sub (:id e))])\n                     (:assignments e))]\n             (fn [db location] [db x]))]]]\n        [db nil]))))&quot; &quot;(show-ast (let [x (g/sin 1.0)\n                z (g/cos 1.0)\n                y (g/if true x z)\n                ]\n            (g/sin\n              (g/clamp\n                z y\n                (g/clamp\n                 (g/if true\n                   (g/cos z)\n                   (g/sin y)) y x\n                 )) )))&quot; &quot;(defn insert-assignments-sub [target-id]\n  (fn [db location]\n    (let [e (get-element db location)]\n      (condp = (:head e)\n        :if\n        [db\n         [(in-path [:body 1] (insert-assignments-sub target-id))\n          (in-path [:body 2] (insert-assignments-sub target-id))]]\n        :block\n        [db\n         [(in-path [:body (- (count (:body e)) 1)] (insert-assignments-sub target-id))\n          ;(insert-assignments)\n          ]]\n\n        [(insert-assignment db location target-id) nil]))))&quot; &quot;(defn insert-assignments []\n  (fn [db location ]\n    (let [e (get-element db location)]\n      (if (= :block (:head e))\n        [db\n         [[:assignments\n           (let [x (map-indexed\n                     (fn [i y] [i (insert-assignments-sub y)])\n                     (:assignments e))]\n             (fn [db location] [db x]))]]]\n        [db nil]))))&quot; &quot;(defn insert-assignments-sub [target-id]\n  (fn [db location]\n    (let [e (get-element db location)]\n      (condp = (:head e)\n        :if\n        [db\n         [(in-path [:body 1] (insert-assignments-sub target-id))\n          (in-path [:body 2] (insert-assignments-sub target-id))]]\n        :block\n        [db\n         [(in-path [:body (- (count (:body e)) 1)] (insert-assignments-sub target-id))\n          ;(insert-assignments)\n          ]]\n        :set \n        [db nil]\n\n        [(insert-assignment db location target-id) nil]))))&quot; &quot;(defn insert-assignments-sub [target-id]\n  (fn [db location]\n    (let [e (get-element db location)]\n      (condp = (:head e)\n        :if\n        [db\n         [(in-path [:body 1] (insert-assignments-sub target-id))\n          (in-path [:body 2] (insert-assignments-sub target-id))]]\n        :block\n        [db\n         [(in-path [:body (- (count (:body e)) 1)] (insert-assignments-sub target-id))\n          ;(insert-assignments)\n          ]]\n        ;:set [db nil]\n\n        [(insert-assignment db location target-id) nil]))))&quot; &quot;(show (let [x (g/sin 1.0)\n            z (g/cos 1.0)\n            y (clamp x z y)\n            ]\n        (g/sin\n          (g/clamp\n            z y\n            (g/clamp\n              (g/if true\n                (g/cos z)\n                (g/sin y)) y x\n              )) )))&quot; &quot;(show (let [x (g/sin 1.0)\n            z (g/cos 1.0)\n            y (g/clamp x z y)\n            ]\n        (g/sin\n          (g/clamp\n            z y\n            (g/clamp\n              (g/if true\n                (g/cos z)\n                (g/sin y)) y x\n              )) )))&quot; &quot;(defn gcompile [input]\n  (-&gt;\n    (transform\n      {:root {:source-id :root :id :root}}\n      (separate-usages\n        (bubble-terms (flatten-ast input)) {} #{}))\n    (transform (lift-assignments :root))\n    (transform (insert-variables #{}))\n    ;(transform (insert-assignments))\n    (transform (move-assignments))\n    )\n  )&quot; &quot;(defn liftable? [db location]\n  (let [e (get-element db location)] \n    (or\n     (= :shared (peek (pop (:path (:parent location)))))\n     (and\n       (#{:if} (:head e)\n         (not ((:env (db (:id (:parent location)))) (:id e))))\n\n       ))))&quot; &quot;(defn liftable? [db location]\n  (let [e (get-element db location)] \n    (or\n     (= :shared (peek (pop (:path (:parent location)))))\n     (and\n       (#{:if} (:head e)\n         (let [env (:env (db (:id (:parent location))))]\n           (not (if env (env (:id e)) false))))))))&quot; &quot;(defn liftable? [db location]\n  (let [e (get-element db location)] \n    (or\n     (= :shared (peek (pop (:path (:parent location)))))\n     (and\n       (#{:if} (:head e))\n       (let [env (:env (db (:id (:parent location))))]\n         (not (if env (env (:id e)) false)))))))&quot; &quot;(defn liftable? [db location]\n  (let [e (get-element db location)] \n    (or\n     (= :shared (peek (pop (:path (:parent location)))))\n     (and\n       (#{:if} (:head e))\n       #_(let [env (:env (db (:id (:parent location))))]\n         (not \n           (if env (env (:id e)) false)))))))&quot; &quot;(defn liftable? [db location]\n  (let [e (get-element db location)] \n    (or\n     (= :shared (peek (pop (:path (:parent location)))))\n     (and\n       (#{:if} (:head e))\n       (let [env (:env (db (:id (:parent location))))]\n         (println env)\n         true\n         #_(not \n           (if env (env (:id e)) false)))))))&quot; &quot;(conj #{} 1)&quot; &quot;(into #{} 1 2 3)&quot; &quot;(into #{} [1 2 3])&quot; &quot;(defn liftable? [db location]\n  (let [e (get-element db location)]\n    (or\n     (= :shared (peek (pop (:path (:parent location)))))\n     (and\n       (#{:if} (:head e))\n       (let [env (into #{} (:env (db (:id (:parent location)))))]\n         (not\n           (if env (env (:id e)) false)))))))&quot; &quot;(show-ast (let [x (g/sin 1.0)\n            z (g/cos 1.0)\n            y (g/if true z x)\n            ]\n        (g/sin\n          (g/clamp\n            z y\n            (g/clamp\n              (g/clamp x\n                       (g/cos z)\n                       (g/sin y)) y x\n              )) )))&quot; &quot;(defn gcompile [input]\n  (-&gt;\n    (transform\n      {:root {:source-id :root :id :root}}\n      (separate-usages\n        (bubble-terms (flatten-ast input)) {} #{}))\n    (transform (lift-assignments :root))\n    (transform (insert-variables #{}))\n    (transform (insert-assignments))\n    (transform (move-assignments))\n    )\n  )&quot; &quot;(show (let [x (g/sin 1.0)\n                z (g/cos 1.0)\n                y (g/if true x z)\n                ]\n            (g/sin\n              (g/clamp\n                z y\n                (g/clamp\n                 (g/if true\n                   (g/cos z)\n                   (g/sin y)) y x\n                 )) )))&quot; &quot;(defn variables [db]\n  (let [a (atom #{})]\n    (walk db (fn [db location]\n               (let [e (get-element db location)]\n                 (if (= :literal (:head e))\n                   (if (= :variable (:tag (:value e)))\n                     (do \n                       (swap! a conj (:value e))\n                       (if (:type (:value e))\n                         nil \n                         (println location))\n                       ))))\n               db))\n    @a\n    ))&quot; &quot;(let [y (gcompile\n          (let [x (g/sin 1.0)\n                y (g/if true x x)]\n            (g/sin\n              (g/clamp\n                (g/if true\n                  (g/cos y)\n                  (g/sin y)) y x\n                ))))]\n\n  (fipp.printer/pprint-document\n    (emit y (y :root))\n    {:width 80})\n  (gamma.compiler.insert-declarations/variables y))&quot; &quot;(let [y (gcompile\n          (let [x (g/sin 1.0)\n                y (g/if true x x)]\n            (g/sin\n              (g/clamp\n                (g/if true\n                  y\n                  y) y x\n                ))))]\n\n  (fipp.printer/pprint-document\n    (emit y (y :root))\n    {:width 80})\n  (gamma.compiler.insert-declarations/variables y))&quot; &quot;(let [y (gcompile\n          (let [x (g/sin 1.0)\n                y (g/if true x x)]\n            (g/sin\n              (g/clamp\n                (g/if true\n                  y\n                  (sin y)) y x\n                ))))]\n\n  (fipp.printer/pprint-document\n    (emit y (y :root))\n    {:width 80})\n  (gamma.compiler.insert-declarations/variables y))&quot; &quot;(defn insert-variables-sub [db location]\n  (let [id (gen-term-id)]\n    (-&gt; db\n        (assoc-in-location (:parent location) id)\n        (assoc-elements [{:id id :head :literal\n                          :type (:type (get-element db location))\n                          :value {:tag :variable :id (:id location)\n                                  :type (:type (get-element db location))}}]))))&quot; &quot;(ns gamma.compiler.separate-usages\n  (:require [loom.graph :as lg]\n            [loom.alg :as lga])\n  (:require [clojure.set :refer [difference union intersection]])\n  (:use [gamma.ast :only [id? gen-term-id]])\n  (:use [gamma.compiler.common :only [merge-elements location-conj get-element map-path assoc-in-parent assoc-elements]]))&quot; &quot;(defn without\n  \&quot;Returns set s with x removed.\&quot;\n  [s x] (difference s #{x}))&quot; &quot;(defn take-1\n  \&quot;Returns the pair [element, s'] where s' is set s with element removed.\&quot;\n  [s] {:pre [(not (empty? s))]}\n  (let [item (first s)]\n    [item (without s item)]))&quot; &quot;(defn no-incoming\n  \&quot;Returns the set of nodes in graph g for which there are no incoming\n  edges, where g is a map of nodes to sets of nodes.\&quot;\n  [g]\n  (let [nodes (set (keys g))\n        have-incoming (apply union (vals g))]\n    (difference nodes have-incoming)))&quot; &quot;(defn normalize\n  \&quot;Returns g with empty outgoing edges added for nodes with incoming\n  edges only.  Example: {:a #{:b}} =&gt; {:a #{:b}, :b #{}}\&quot;\n  [g]\n  (let [have-incoming (apply union (vals g))]\n    (reduce #(if (get % %2) % (assoc % %2 #{})) g have-incoming)))&quot; &quot;(defn kahn-sort\n  \&quot;Proposes a topological sort for directed graph g using Kahn's\n   algorithm, where g is a map of nodes to sets of nodes. If g is\n   cyclic, returns nil.\&quot;\n  ([g]\n    (kahn-sort (normalize g) [] (no-incoming g)))\n  ([g l s]\n    (if (empty? s)\n      (when (every? empty? (vals g)) l)\n      (let [[n s'] (take-1 s)\n            m (g n)\n            g' (reduce #(update-in % [n] without %2) g m)]\n        (recur g' (conj l n) (union s' (intersection (no-incoming g') m)))))))&quot; &quot;(def acyclic-g\n    {7 #{11 8}\n     5 #{11}\n     3 #{8 10}\n     11 #{2 9}\n     8 #{9}})&quot; &quot;(def acyclic-g\n    {7 [11 8] \n     5 #{11}\n     3 #{8 10}\n     11 #{2 9}\n     8 #{9}})&quot; &quot;(kahn-sort acyclic-g)&quot; &quot;(defn topological-sort [ids db]\n  (let [graph (into {}\n                    (map (fn [id]\n                           [id (into #{} (filter (:shared (db id) {}) ids))])\n                         ids))]\n\n    (if (= {} graph)\n      []\n      (reverse (kahn-sort graph)))))&quot; &quot;(let [y (gcompile\n          (let [x (g/sin 1.0)\n                y (g/if true x x)]\n            (g/sin\n              (g/clamp\n                (g/if true\n                  y\n                  (g/sin y)) y x\n                ))))]\n\n  (fipp.printer/pprint-document\n    (emit y (y :root))\n    {:width 80})\n  (gamma.compiler.insert-declarations/variables y))&quot; &quot;(show (let [x (g/sin 1.0)\n            z (g/cos 1.0)\n            y (g/if true z x)\n            ]\n        (g/sin\n          (g/clamp\n            z y\n            (g/clamp\n              (g/clamp x\n                       (g/cos z)\n                       (g/sin y)) y x\n              )) )))&quot; &quot;(show (let [x (g/sin 1.0)\n            z (g/cos 1.0)\n            y (g/clamp x z x)\n            ]\n        (g/sin\n          (g/clamp\n            z y\n            (g/clamp\n              (g/clamp x\n                (g/cos z)\n                (g/sin y)) y x\n              )) )))&quot; &quot;(show (let [x (g/sin 1.0)\n            z (g/cos 1.0)\n            y (g/clamp x z x)\n            ]\n        (g/sin\n          (g/clamp\n            z y\n            (g/clamp\n              (g/if true\n                (g/cos z)\n                (g/sin y)) y x\n              )) )))&quot; &quot;(require '[cljs.repl.rhino :as rhino])&quot; &quot;(def env (rhino/repl-env)) &quot; &quot;(repl/repl env)&quot; &quot;(require '[cljs.repl :as repl])\n(require '[cljs.repl.rhino :as rhino]) ;; require the rhino implementation of IJavaScriptEnv\n(def env (rhino/repl-env)) ;; create a new environment\n(repl/repl env) ;; start the REPL&quot; &quot;1&quot; &quot;(require '[cljs.repl :as repl])&quot; &quot;(require '[cljs.repl.node :as node]) &quot; &quot;(def env (node/repl-env))&quot; &quot;(repl/repl env) &quot; &quot;env &quot; &quot;(group-by #(:storage (first %)) {{:storage :a} 1 {:storage b} 2})&quot; &quot;(group-by #(:storage (first %)) {{:storage :a} 1 {:storage :b} 2})&quot;], :remote []}}</component>
</project>

