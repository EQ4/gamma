<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1420242256085">{:repl-history {:ide [], :local [&quot;(defn bubble-term-set-step [set db]\n  (mapcat\n    (fn [t]\n      (if (terminal? (last t) db)\n        [t]\n        (map #(conj t (db %)) (:parents (last t)))))\n    set ))&quot; &quot;(defn bubble-term-set [set db]\n  (let [s (iterate #(bubble-term-set-step % db) db)]\n    (loop [c (first s) n (next s)]\n      (if (= c (first n))\n        n\n        (recur (first n) (next n))))))&quot; &quot;(defn flatten-ast [db node parent-id]\n  (let [id (:id node) seen (db id)]\n    (if seen\n      (update-in db [id :parents] conj parent-id)\n      (if (= :literal (head node))\n        (assoc db id (assoc node :parents [parent-id]))\n        (reduce\n          #(flatten-ast %1 %2 id)\n          (assoc db (:id node)\n                 (assoc node\n                        :body (map :id (body node))\n                        :parents [parent-id]))\n          (body node))))))&quot; &quot;(flatten-ast {} (term :bar 0 (term :foo 1)) :root)&quot; &quot;(defn flatten-ast\n  ([node] (flatten-ast {:root {:id :root :head :root :body [(:id node)] :parents [:root]}} node :root))\n  ([db node parent-id]\n   (let [id (:id node) seen (db id)]\n     (if seen\n       (update-in db [id :parents] conj parent-id)\n       (if (= :literal (head node))\n         (assoc db id (assoc node :parents [parent-id]))\n         (reduce\n           #(flatten-ast %1 %2 id)\n           (assoc db (:id node)\n                  (assoc node\n                         :body (map :id (body node))\n                         :parents [parent-id]))\n           (body node)))))))&quot; &quot;(flatten-ast (term :bar 0 (term :foo 1)))&quot; &quot;(map identity 1)&quot; &quot;(def db (let [dup (term :foo)] \n            (flatten-ast (term :bar foo (term :baz foo)))) \n    \n    (term :baz (term :foo)))&quot; &quot;(term :baz (term :foo))&quot; &quot;(flatten-ast (term :foo ))&quot; &quot;(flatten-ast (term :bar (term :foo)))&quot; &quot;(flatten-ast (term :bar (term :baz) (term :foo)))&quot; &quot;(def foo (term :foo))&quot; &quot;(flatten-ast (term :bar foo foo))&quot; &quot;(flatten-ast (term :bar foo (term :baz foo)))&quot; &quot;(def db (let [dup (term :foo)] \n            (flatten-ast (term :bar dup (term :baz dup)))))&quot; &quot;db&quot; &quot;(:root db)&quot; &quot;(select #(&gt; 1 (count (:parents %))) (map last db))&quot; &quot;(filter #(&gt; 1 (count (:parents %))) (map last db))&quot; &quot;(filter #(&lt; 1 (count (:parents %))) (map last db))&quot; &quot;(map #(count (:parents %)) (map last db))&quot; &quot;(count (filter #(&lt; 1 (count (:parents %)))\n           (map last db)))&quot; &quot;(filter #(not= 1 (count (:parents %)))\n          (map last db))&quot; &quot;(filter #(&gt; 1 (count (:parents %)))\n          (map last db))&quot; &quot;(filter #(&lt; 10 (count (:parents %)))\n          (map last db))&quot; &quot;(&lt; 10 20)&quot; &quot;(filter #(clojure.core/&lt; 1 (count (:parents %)))\n          (map last db))&quot; &quot;(defn bubble-terms [db]\n  (map #(bubble-term-set (vector (vector %)) db)\n       (filter #(clojure.core/&lt; 1 (count (:parents %)))\n           (map last db))))&quot; &quot;(bubble-terms (flatten-ast (term :bar foo (term :baz foo))))&quot; &quot;(:root (flatten-ast (term :bar 0 (term :foo 1))))&quot; &quot;(filter #(&lt; 1 (count (:parents %)))\n          (map last db))&quot; &quot;(map vector \n       (filter #(&lt; 1 (count (:parents %)))\n           (map last db)))&quot; &quot;(bubble-term-set-step \n    (map vector\n        (filter #(&lt; 1 (count (:parents %)))\n                (map last db)))\n    db)&quot; &quot;(bubble-term-set-step \n    (bubble-term-set-step\n     (map vector\n          (filter #(&lt; 1 (count (:parents %)))\n                  (map last db)))\n     db) db)&quot; &quot;(bubble-term-set-step \n    (bubble-term-set-step\n     (bubble-term-set-step\n       (map vector\n            (filter #(&lt; 1 (count (:parents %)))\n                    (map last db)))\n       db) db) db)&quot; &quot;(count (bubble-term-set-step\n     (bubble-term-set-step\n       (bubble-term-set-step\n         (map vector\n              (filter #(&lt; 1 (count (:parents %)))\n                      (map last db)))\n         db) db) db))&quot; &quot;(=\n    (bubble-term-set-step\n      (bubble-term-set-step\n        (bubble-term-set-step\n          (map vector\n               (filter #(&lt; 1 (count (:parents %)))\n                       (map last db)))\n          db) db) db)\n\n    (bubble-term-set-step \n      (bubble-term-set-step\n       (bubble-term-set-step\n         (bubble-term-set-step\n           (map vector\n                (filter #(&lt; 1 (count (:parents %)))\n                        (map last db)))\n           db) db) db) db))&quot; &quot;(defn bubble-term-set [set db]\n  (let [s (iterate #(bubble-term-set-step % db) set)]\n    (loop [c (first s) n (next s)]\n      (if (= c (first n))\n        n\n        (recur (first n) (next n))))))&quot; &quot;(def db (let [dup (term :foo)]\n            (flatten-ast (term :bar dup (term :baz dup)))))&quot; &quot;(bubble-term-set\n    (map vector\n         (filter #(&lt; 1 (count (:parents %)))\n                 (map last db)))\n    db)&quot; &quot;(count *1)&quot; &quot;(bubble-terms db)&quot; &quot;(flatten-ast {} (let [x (term :foo)]\n                    (term :bar x x)) :root)&quot; &quot;(flatten-ast (term :block (term :if true (term :if true true))))&quot; &quot;(def x (flatten-ast (term :block (term :if true (term :if true true)))))&quot; &quot;(:root x)&quot; &quot;(x (first (:body (:root x))))&quot; &quot;(defn lift-assignments [current-id parent-block-id db]\n  (let [e (db current-id)]\n    (cond\n      (literal? e)\n      db\n\n      (statement? e)\n      (let [db2 (update-in db [parent-block-id :assignments] cons (:id e))]\n        (reduce #(lift-assignments %2 parent-block-id %1) db2 (:body e)))\n\n      (block? e)\n      (let [db2 (assoc-in db [current-id :assignments] (list))]\n        (reduce #(lift-assignments %2 current-id %1) db2 (:body e)))\n\n\n      :default\n      (reduce #(lift-assignments %2 parent-block-id %1) db (:body e))\n\n      )))&quot; &quot;(defn lift-assignments [current-id parent-block-id db]\n  (let [e (db current-id)]\n    (cond\n      (literal? e)\n      db\n\n      (statement? e)\n      (let [db2 (update-in db [parent-block-id :assignments] conj (:id e))]\n        (reduce #(lift-assignments %2 parent-block-id %1) db2 (:body e)))\n\n      (block? e)\n      (let [db2 (assoc-in db [current-id :assignments] [])]\n        (reduce #(lift-assignments %2 current-id %1) db2 (:body e)))\n\n\n      :default\n      (reduce #(lift-assignments %2 parent-block-id %1) db (:body e))\n\n      )))&quot; &quot;(lift-assignments 11 11 x)&quot; &quot;(clojure.pprint/pprint (let [x (term :foo)]\n     (term :bar\n           (term :baz x)\n           (term :baz x))))&quot; &quot;(def db\n    (flatten-ast {} (let [x (term :foo)]\n                      (term :bar\n                            (term :baz x)\n                            (term :baz x))) :root))&quot; &quot;(clojure.pprint/pprint db)&quot; &quot;(fipp.printer/pprint-document\n    (ast-doc\n      db\n      1050\n      nil) {:width 20})&quot; &quot;(def db\n    (flatten-ast (let [x (term :foo)]\n                      (term :bar\n                            (term :baz x)\n                            (term :baz x)))))&quot; &quot;(fipp.printer/pprint-document\n    (ast-doc\n      db\n      :root\n      nil) {:width 20})&quot; &quot;(fipp.printer/pprint-document\n    (ast-doc\n      (lift-assignments 11 11 x)\n      :root\n      nil) {:width 20})&quot; &quot;(fipp.printer/pprint-document\n    (ast-doc\n      (lift-assignments 11 11 x)\n      :root\n      :assignments) {:width 20})&quot; &quot;(fipp.printer/pprint-document\n    (ast-doc\n      (lift-assignments 11 11 x)\n      :root\n      (fn [x db] (:assignments (db x)))) {:width 20})&quot; &quot;(fipp.printer/pprint-document\n    (ast-doc\n      (lift-assignments 11 11 x)\n      :root\n      (fn [x db] (:assignments x))) {:width 20})&quot; &quot;(fipp.printer/pprint-document\n    (ast-doc\n      (lift-assignments 11 11 x)\n      :root\n      (fn [x db] (:assignments x))) {:width 40})&quot; &quot;(fipp.printer/pprint-document\n    (ast-doc\n      (lift-assignments 11 11 x)\n      :root\n      (fn [x db] [(:id x) (:assignments x)])) {:width 40})&quot; &quot;(defn if [c a b]\n  (term :if c (term :block a) (term :block b)))&quot; &quot;(if 1 2 3)&quot; &quot;1&quot; &quot;(use 'gamma.compiler)&quot; &quot;(def x (flatten-ast (term :if true (term :if true true))))&quot; &quot;(require '[fipp.edn :refer (pprint) :rename {pprint fipp}])&quot; &quot;(require 'fipp.printer)&quot; &quot;(defn ast-doc [db node-id f]\n    (let [x (db node-id)]\n      [:group\n      (name (head x))\n       (if f\n         (if-let [y (f x db)]\n          (pr-str y)\n          \&quot;\&quot;))\n      \&quot;[\&quot;\n      [:line \&quot;\&quot;]\n       (if (= :literal (head x))\n         (pr-str (:body x))\n         [:nest 2\n         (interpose [:span \&quot;,\&quot; :line]\n                    (map #(ast-doc db % f) (body x)))])\n      \&quot;]\&quot;]))&quot; &quot;(require '[gamma.api :as g])&quot; &quot;(require '[gamma.api :as g] :reload)&quot; &quot;(def x (flatten-ast (g/if true (g/if true true)) ))&quot; &quot;(g/if 1 2 3)&quot; &quot;(g/if true true (g/if true true true))&quot; &quot;(term :if true true)&quot; &quot;(in-ns 'gamma.api)&quot; &quot;(defn if [c a b]\n  (ast/term :if c (ast/term :block a) (ast/term :block b)))&quot; &quot;(in-ns 'gamma.compiler)&quot; &quot;(def x (flatten-ast (g/if true true (g/if true true true)) ))&quot; &quot;(lift-assignments x)&quot; &quot;(fipp.printer/pprint-document\n    (ast-doc\n      (lift-assignments x)\n      :root\n      (fn [x db] [(:id x) (:assignments x)])) {:width 40})&quot; &quot;(defn bubble-term [db queue]\n  (let [bubble (first queue)]\n    (if (nil? bubble)\n     ;; base case. If bubble is nil, return the db we've built up\n     db\n     (if (= :root (:current bubble))\n       ;; if bubble has reached the root node, recur to the next bubble in the queue\n       (recur db (rest queue))\n       ;; if not at the root node, inspect and mark node and recur\n       (let [info-path [(:current bubble) :shared (:start bubble)]\n             node-info (get-in db info-path)]\n         (if (:conditional bubble)\n           ;; bubble is conditional\n           (if (nil? node-info)\n             ;; node hasn't been visited before; mark and bubble\n             (let [parent-bubbles (parent-bubbles db bubble)]\n               (recur (assoc-in db info-path {:conditional true}) (concat (rest queue) parent-bubbles)))\n             (if (:unconditional node-info)\n               ;; node has been visited by an unconditional bubble. mark conditional and recur to next bubble\n               (recur (assoc-in db (conj info-path :conditional) true) (rest queue))\n               ;; node has been visited by conditional bubble. recur to next bubble\n               (recur db (rest queue))))\n\n           ;; bubble is unconditional\n           (if (or (nil? node-info) (nil? (:unconditional node-info)))\n             ;; node has not been visited by an unconditional bubble. mark and bubble\n             (let [parent-bubbles (parent-bubbles db bubble)]\n               (recur (assoc-in db info-path (assoc node-info :unconditional 1)) (concat queue parent-bubbles)))\n             ;; node has been visited by unconditional bubble. increment and recur to next bubble.\n             (recur\n               (assoc-in db info-path (assoc node-info :unconditional (+ 1 (:unconditional node-info))))\n               (rest queue))))\n\n         )))))&quot; &quot;(let [y (term :plus 1 2)] \n    (def x (flatten-ast (term :plus y y))))&quot; &quot;(defn print-ast [x f w]\n  (fipp.printer/pprint-document\n    (ast-doc\n      x\n      :root\n      f) {:width w}))&quot; &quot;(print-ast x nil 30)&quot; &quot;(print-ast x (fn [x db] [(:id x) (:shared x)]) 30)&quot; &quot;(defn bubble-terms [db]\n  (reduce bubble-term db\n          (map \n            (fn [x] (map (fn [y] {:start (:id x)  :current y}) (:parents x)))\n            (filter #(clojure.core/&lt; 1 (count (:parents %)))\n                   (map last db)))))&quot; &quot;(bubble-terms x)&quot; &quot;(defn bubble-term [db queue]\n  (let [bubble (first queue)]\n    (if (nil? bubble)\n     ;; base case. If bubble is nil, return the db we've built up\n     db\n     (if (= :root (:current bubble))\n       ;; if bubble has reached the root node, recur to the next bubble in the queue\n       (recur db (rest queue))\n       ;; if not at the root node, inspect and mark node and recur\n       (let [info-path [(:current bubble) :shared (:start bubble)]\n             node-info (get-in db info-path)]\n         (if (:conditional bubble)\n           ;; bubble is conditional\n           (if (nil? node-info)\n             ;; node hasn't been visited before; mark and bubble\n             (let [parent-bubbles (parent-bubbles db bubble)]\n               (recur (assoc-in db info-path {:conditional true}) (concat (rest queue) parent-bubbles)))\n             (if (:unconditional node-info)\n               ;; node has been visited by an unconditional bubble. mark conditional and recur to next bubble\n               (recur (assoc-in db (conj info-path :conditional) true) (rest queue))\n               ;; node has been visited by conditional bubble. recur to next bubble\n               (recur db (rest queue))))\n\n           ;; bubble is unconditional\n           (if (or (nil? node-info) (nil? (:unconditional node-info)))\n             ;; node has not been visited by an unconditional bubble. mark and bubble\n             (let [parent-bubbles (parent-bubbles db bubble)]\n               (recur (assoc-in db info-path (assoc node-info :unconditional 1)) (concat (rest queue) parent-bubbles)))\n             ;; node has been visited by unconditional bubble. increment and recur to next bubble.\n             (recur\n               (assoc-in db info-path (assoc node-info :unconditional (+ 1 (:unconditional node-info))))\n               (rest queue))))\n\n         )))))&quot; &quot;(print-ast (bubble-terms x)\n             (fn [x db] [(:id x) (:shared x)]) 30)&quot; &quot;(let [x (term :plus 1 2)\n        y (term :plus x x)] \n    (print-ast (bubble-terms (flatten-ast y))\n              (fn [x db] [(:id x) (:shared x)]) 30))&quot; &quot;(let [x (term :plus 1 2)\n        y (term :plus x x x)] \n    (print-ast (bubble-terms (flatten-ast y))\n              (fn [x db] [(:id x) (:shared x)]) 30))&quot; &quot;(gamma.ast/gen-term-id)&quot; &quot;(repeatedly 5 (gamma.ast/gen-term-id))&quot; &quot;(repeatedly 5 gamma.ast/gen-term-id)&quot; &quot;(let [x (term :plus 1 2)\n        y (term :plus x x (g/if true 1 x))]\n    (print-ast (bubble-terms (flatten-ast y))\n               (fn [x db] [(:id x) (:shared x)]) 30))&quot; &quot;(defn shared-set [x]\n  (into #{}\n        (map first\n             (filter (fn [y] (let [u (:unconditional (last y)) c (:conditional (last y))] (if u (&lt;= 2 u))))\n                     x))))&quot; &quot;(defn separate-usages [db new-db parent-id id new-id env]\n  (let [x (db id)\n        s (shared-set (:shared x))\n        s2 (filter #(not (env %)) s)\n        ]\n    (let [new-children-ids (repeatedly (count (:body x)) gamma.ast/gen-term-id)\n          new-shared-ids (repeatedly (count s2) gamma.ast/gen-term-id)\n          new-env (merge env (zipmap s2 new-shared-ids))\n          new-db (reduce #(separate-usages db % new-id (first %2) (last %2) env)\n                         new-db\n                         (map list s2 new-shared-ids))\n          new-db (reduce #(separate-usages db % new-id (first %2) (last %2) new-env)\n                         new-db\n                         (filter #(not (new-env (first %)))\n                                 (map list (:body x) new-children-ids)))\n\n\n\n          ]\n      (assoc new-db\n             new-id\n             (assoc x :body (map #(if (new-env %1) (new-env %1) %2) (:body x) new-children-ids)\n                    :shared s2 :parents [parent-id])))))&quot; &quot;(let [x (term :plus 1 2)\n        y (term :plus x x (g/if true 1 x))]\n    (separate-usages  \n      (bubble-terms (flatten-ast y))\n      {}\n      :root \n      :root \n      :root \n      {}))&quot;], :remote []}}</component>
</project>

