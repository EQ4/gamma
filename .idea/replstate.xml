<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1430427041654">{:repl-history {:ide [], :local [&quot;(defn variables [db]\n  (let [a (atom #{})]\n    (walk db (fn [db location]\n               (let [e (get-element db location)]\n                 (if (= :literal (:head e))\n                   (if (= :variable (:tag (:value e)))\n                     (swap! a conj (:value e)))))\n               db))\n    @a\n    ))&quot; &quot;(gamma.compiler.insert-declarations/variables (gcompile\n   (let [x (g/sin 1.0)\n         y (g/if true x x)]\n     (g/sin\n       (g/clamp\n         (g/if true\n           (g/cos y)\n           (g/sin y)) y x\n         )))))&quot; &quot;(in-ns 'gamma.examples)&quot; &quot;(g/sin 1.0)&quot; &quot;(:type (g/sin 1.0))&quot; &quot;(let [x (g/sin 1.0)] (g/if true x x))&quot; &quot;(:type (let [x (g/sin 1.0)] (g/if true x x)))&quot; &quot;(gamma.compiler.insert-declarations/variables\n  (gcompile\n    (let [x (g/sin 1.0)\n          y (g/if true x x)]\n      (g/sin\n        (g/clamp\n          (g/if true\n            (g/cos y)\n            (g/sin y)) y x\n          )))))&quot; &quot;(defn insert-assignment [db location target-id]\n  (let [set-id (gen-term-id) var-id (gen-term-id)\n        this-id (:id location) parent-loc (:parent location)]\n    ;(println [this-id ])\n    (-&gt; db\n        (assoc-elements [{:id set-id :head :set :body [var-id this-id]}\n                         {:id var-id :head :literal\n                          :value {:tag :variable :id target-id\n                                  :type (:type (db target-id))}}])\n        (assoc-in-location parent-loc set-id))))&quot; &quot;(show (let [x (g/sin 1.0)\n            y (g/if true x x)]\n            (g/sin\n              (g/clamp\n               (g/if true\n                 (g/cos y)\n                 (g/sin y) )y x\n               ) )))&quot; &quot;(show-ast (let [x (g/sin 1.0)\n            y (g/if true x x)]\n            (g/sin\n              (g/clamp\n               (g/if true\n                 (g/cos y)\n                 (g/sin y) )y x\n               ) )))&quot; &quot;(show (let [x (g/sin 1.0)\n                z (g/cos 1.0)\n                y (g/if true x z)\n                ]\n            (g/sin\n              (g/clamp \n                z y\n                (g/clamp\n                 (g/if true\n                   (g/cos z)\n                   (g/sin y)) y x\n                 )) )))&quot; &quot;(defn insert-assignment [db location target-id]\n  (let [set-id (gen-term-id) var-id (gen-term-id)\n        this-id (:id location) parent-loc (:parent location)]\n    ;(println [this-id ])\n    (-&gt; db\n        (assoc-elements [{:id set-id :head :set :body [var-id this-id]}\n                         {:id var-id :head :literal\n                          :value {:tag :variable :id target-id\n                                  :type (:type (get-element db location))}}])\n        (assoc-in-location parent-loc set-id))))&quot; &quot;(defn insert-assignments []\n  (fn [db location ]\n    (let [e (get-element db location)]\n      (if (= :block (:head e))\n        [db\n         [[:assignments\n           (let [x (map-indexed\n                     (fn [i y] [i (insert-assignments-sub (:id e))])\n                     (:assignments e))]\n             (fn [db location] [db x]))]]]\n        [db nil]))))&quot; &quot;(show-ast (let [x (g/sin 1.0)\n                z (g/cos 1.0)\n                y (g/if true x z)\n                ]\n            (g/sin\n              (g/clamp\n                z y\n                (g/clamp\n                 (g/if true\n                   (g/cos z)\n                   (g/sin y)) y x\n                 )) )))&quot; &quot;(defn insert-assignments-sub [target-id]\n  (fn [db location]\n    (let [e (get-element db location)]\n      (condp = (:head e)\n        :if\n        [db\n         [(in-path [:body 1] (insert-assignments-sub target-id))\n          (in-path [:body 2] (insert-assignments-sub target-id))]]\n        :block\n        [db\n         [(in-path [:body (- (count (:body e)) 1)] (insert-assignments-sub target-id))\n          ;(insert-assignments)\n          ]]\n\n        [(insert-assignment db location target-id) nil]))))&quot; &quot;(defn insert-assignments []\n  (fn [db location ]\n    (let [e (get-element db location)]\n      (if (= :block (:head e))\n        [db\n         [[:assignments\n           (let [x (map-indexed\n                     (fn [i y] [i (insert-assignments-sub y)])\n                     (:assignments e))]\n             (fn [db location] [db x]))]]]\n        [db nil]))))&quot; &quot;(defn insert-assignments-sub [target-id]\n  (fn [db location]\n    (let [e (get-element db location)]\n      (condp = (:head e)\n        :if\n        [db\n         [(in-path [:body 1] (insert-assignments-sub target-id))\n          (in-path [:body 2] (insert-assignments-sub target-id))]]\n        :block\n        [db\n         [(in-path [:body (- (count (:body e)) 1)] (insert-assignments-sub target-id))\n          ;(insert-assignments)\n          ]]\n        :set \n        [db nil]\n\n        [(insert-assignment db location target-id) nil]))))&quot; &quot;(defn insert-assignments-sub [target-id]\n  (fn [db location]\n    (let [e (get-element db location)]\n      (condp = (:head e)\n        :if\n        [db\n         [(in-path [:body 1] (insert-assignments-sub target-id))\n          (in-path [:body 2] (insert-assignments-sub target-id))]]\n        :block\n        [db\n         [(in-path [:body (- (count (:body e)) 1)] (insert-assignments-sub target-id))\n          ;(insert-assignments)\n          ]]\n        ;:set [db nil]\n\n        [(insert-assignment db location target-id) nil]))))&quot; &quot;(show (let [x (g/sin 1.0)\n            z (g/cos 1.0)\n            y (clamp x z y)\n            ]\n        (g/sin\n          (g/clamp\n            z y\n            (g/clamp\n              (g/if true\n                (g/cos z)\n                (g/sin y)) y x\n              )) )))&quot; &quot;(show (let [x (g/sin 1.0)\n            z (g/cos 1.0)\n            y (g/clamp x z y)\n            ]\n        (g/sin\n          (g/clamp\n            z y\n            (g/clamp\n              (g/if true\n                (g/cos z)\n                (g/sin y)) y x\n              )) )))&quot; &quot;(defn gcompile [input]\n  (-&gt;\n    (transform\n      {:root {:source-id :root :id :root}}\n      (separate-usages\n        (bubble-terms (flatten-ast input)) {} #{}))\n    (transform (lift-assignments :root))\n    (transform (insert-variables #{}))\n    ;(transform (insert-assignments))\n    (transform (move-assignments))\n    )\n  )&quot; &quot;(defn liftable? [db location]\n  (let [e (get-element db location)] \n    (or\n     (= :shared (peek (pop (:path (:parent location)))))\n     (and\n       (#{:if} (:head e)\n         (not ((:env (db (:id (:parent location)))) (:id e))))\n\n       ))))&quot; &quot;(defn liftable? [db location]\n  (let [e (get-element db location)] \n    (or\n     (= :shared (peek (pop (:path (:parent location)))))\n     (and\n       (#{:if} (:head e)\n         (let [env (:env (db (:id (:parent location))))]\n           (not (if env (env (:id e)) false))))))))&quot; &quot;(defn liftable? [db location]\n  (let [e (get-element db location)] \n    (or\n     (= :shared (peek (pop (:path (:parent location)))))\n     (and\n       (#{:if} (:head e))\n       (let [env (:env (db (:id (:parent location))))]\n         (not (if env (env (:id e)) false)))))))&quot; &quot;(defn liftable? [db location]\n  (let [e (get-element db location)] \n    (or\n     (= :shared (peek (pop (:path (:parent location)))))\n     (and\n       (#{:if} (:head e))\n       #_(let [env (:env (db (:id (:parent location))))]\n         (not \n           (if env (env (:id e)) false)))))))&quot; &quot;(defn liftable? [db location]\n  (let [e (get-element db location)] \n    (or\n     (= :shared (peek (pop (:path (:parent location)))))\n     (and\n       (#{:if} (:head e))\n       (let [env (:env (db (:id (:parent location))))]\n         (println env)\n         true\n         #_(not \n           (if env (env (:id e)) false)))))))&quot; &quot;(conj #{} 1)&quot; &quot;(into #{} 1 2 3)&quot; &quot;(into #{} [1 2 3])&quot; &quot;(defn liftable? [db location]\n  (let [e (get-element db location)]\n    (or\n     (= :shared (peek (pop (:path (:parent location)))))\n     (and\n       (#{:if} (:head e))\n       (let [env (into #{} (:env (db (:id (:parent location)))))]\n         (not\n           (if env (env (:id e)) false)))))))&quot; &quot;(show-ast (let [x (g/sin 1.0)\n            z (g/cos 1.0)\n            y (g/if true z x)\n            ]\n        (g/sin\n          (g/clamp\n            z y\n            (g/clamp\n              (g/clamp x\n                       (g/cos z)\n                       (g/sin y)) y x\n              )) )))&quot; &quot;(defn gcompile [input]\n  (-&gt;\n    (transform\n      {:root {:source-id :root :id :root}}\n      (separate-usages\n        (bubble-terms (flatten-ast input)) {} #{}))\n    (transform (lift-assignments :root))\n    (transform (insert-variables #{}))\n    (transform (insert-assignments))\n    (transform (move-assignments))\n    )\n  )&quot; &quot;(show (let [x (g/sin 1.0)\n                z (g/cos 1.0)\n                y (g/if true x z)\n                ]\n            (g/sin\n              (g/clamp\n                z y\n                (g/clamp\n                 (g/if true\n                   (g/cos z)\n                   (g/sin y)) y x\n                 )) )))&quot; &quot;(defn variables [db]\n  (let [a (atom #{})]\n    (walk db (fn [db location]\n               (let [e (get-element db location)]\n                 (if (= :literal (:head e))\n                   (if (= :variable (:tag (:value e)))\n                     (do \n                       (swap! a conj (:value e))\n                       (if (:type (:value e))\n                         nil \n                         (println location))\n                       ))))\n               db))\n    @a\n    ))&quot; &quot;(let [y (gcompile\n          (let [x (g/sin 1.0)\n                y (g/if true x x)]\n            (g/sin\n              (g/clamp\n                (g/if true\n                  (g/cos y)\n                  (g/sin y)) y x\n                ))))]\n\n  (fipp.printer/pprint-document\n    (emit y (y :root))\n    {:width 80})\n  (gamma.compiler.insert-declarations/variables y))&quot; &quot;(let [y (gcompile\n          (let [x (g/sin 1.0)\n                y (g/if true x x)]\n            (g/sin\n              (g/clamp\n                (g/if true\n                  y\n                  y) y x\n                ))))]\n\n  (fipp.printer/pprint-document\n    (emit y (y :root))\n    {:width 80})\n  (gamma.compiler.insert-declarations/variables y))&quot; &quot;(let [y (gcompile\n          (let [x (g/sin 1.0)\n                y (g/if true x x)]\n            (g/sin\n              (g/clamp\n                (g/if true\n                  y\n                  (sin y)) y x\n                ))))]\n\n  (fipp.printer/pprint-document\n    (emit y (y :root))\n    {:width 80})\n  (gamma.compiler.insert-declarations/variables y))&quot; &quot;(defn insert-variables-sub [db location]\n  (let [id (gen-term-id)]\n    (-&gt; db\n        (assoc-in-location (:parent location) id)\n        (assoc-elements [{:id id :head :literal\n                          :type (:type (get-element db location))\n                          :value {:tag :variable :id (:id location)\n                                  :type (:type (get-element db location))}}]))))&quot; &quot;(ns gamma.compiler.separate-usages\n  (:require [loom.graph :as lg]\n            [loom.alg :as lga])\n  (:require [clojure.set :refer [difference union intersection]])\n  (:use [gamma.ast :only [id? gen-term-id]])\n  (:use [gamma.compiler.common :only [merge-elements location-conj get-element map-path assoc-in-parent assoc-elements]]))&quot; &quot;(defn without\n  \&quot;Returns set s with x removed.\&quot;\n  [s x] (difference s #{x}))&quot; &quot;(defn take-1\n  \&quot;Returns the pair [element, s'] where s' is set s with element removed.\&quot;\n  [s] {:pre [(not (empty? s))]}\n  (let [item (first s)]\n    [item (without s item)]))&quot; &quot;(defn no-incoming\n  \&quot;Returns the set of nodes in graph g for which there are no incoming\n  edges, where g is a map of nodes to sets of nodes.\&quot;\n  [g]\n  (let [nodes (set (keys g))\n        have-incoming (apply union (vals g))]\n    (difference nodes have-incoming)))&quot; &quot;(defn normalize\n  \&quot;Returns g with empty outgoing edges added for nodes with incoming\n  edges only.  Example: {:a #{:b}} =&gt; {:a #{:b}, :b #{}}\&quot;\n  [g]\n  (let [have-incoming (apply union (vals g))]\n    (reduce #(if (get % %2) % (assoc % %2 #{})) g have-incoming)))&quot; &quot;(defn kahn-sort\n  \&quot;Proposes a topological sort for directed graph g using Kahn's\n   algorithm, where g is a map of nodes to sets of nodes. If g is\n   cyclic, returns nil.\&quot;\n  ([g]\n    (kahn-sort (normalize g) [] (no-incoming g)))\n  ([g l s]\n    (if (empty? s)\n      (when (every? empty? (vals g)) l)\n      (let [[n s'] (take-1 s)\n            m (g n)\n            g' (reduce #(update-in % [n] without %2) g m)]\n        (recur g' (conj l n) (union s' (intersection (no-incoming g') m)))))))&quot; &quot;(def acyclic-g\n    {7 #{11 8}\n     5 #{11}\n     3 #{8 10}\n     11 #{2 9}\n     8 #{9}})&quot; &quot;(def acyclic-g\n    {7 [11 8] \n     5 #{11}\n     3 #{8 10}\n     11 #{2 9}\n     8 #{9}})&quot; &quot;(kahn-sort acyclic-g)&quot; &quot;(defn topological-sort [ids db]\n  (let [graph (into {}\n                    (map (fn [id]\n                           [id (into #{} (filter (:shared (db id) {}) ids))])\n                         ids))]\n\n    (if (= {} graph)\n      []\n      (reverse (kahn-sort graph)))))&quot; &quot;(let [y (gcompile\n          (let [x (g/sin 1.0)\n                y (g/if true x x)]\n            (g/sin\n              (g/clamp\n                (g/if true\n                  y\n                  (g/sin y)) y x\n                ))))]\n\n  (fipp.printer/pprint-document\n    (emit y (y :root))\n    {:width 80})\n  (gamma.compiler.insert-declarations/variables y))&quot; &quot;(show (let [x (g/sin 1.0)\n            z (g/cos 1.0)\n            y (g/if true z x)\n            ]\n        (g/sin\n          (g/clamp\n            z y\n            (g/clamp\n              (g/clamp x\n                       (g/cos z)\n                       (g/sin y)) y x\n              )) )))&quot; &quot;(show (let [x (g/sin 1.0)\n            z (g/cos 1.0)\n            y (g/clamp x z x)\n            ]\n        (g/sin\n          (g/clamp\n            z y\n            (g/clamp\n              (g/clamp x\n                (g/cos z)\n                (g/sin y)) y x\n              )) )))&quot; &quot;(show (let [x (g/sin 1.0)\n            z (g/cos 1.0)\n            y (g/clamp x z x)\n            ]\n        (g/sin\n          (g/clamp\n            z y\n            (g/clamp\n              (g/if true\n                (g/cos z)\n                (g/sin y)) y x\n              )) )))&quot; &quot;(require '[cljs.repl.rhino :as rhino])&quot; &quot;(def env (rhino/repl-env)) &quot; &quot;(repl/repl env)&quot; &quot;(require '[cljs.repl :as repl])\n(require '[cljs.repl.rhino :as rhino]) ;; require the rhino implementation of IJavaScriptEnv\n(def env (rhino/repl-env)) ;; create a new environment\n(repl/repl env) ;; start the REPL&quot; &quot;(require '[cljs.repl :as repl])&quot; &quot;(require '[cljs.repl.node :as node]) &quot; &quot;(def env (node/repl-env))&quot; &quot;(repl/repl env) &quot; &quot;env &quot; &quot;(group-by #(:storage (first %)) {{:storage :a} 1 {:storage b} 2})&quot; &quot;(group-by #(:storage (first %)) {{:storage :a} 1 {:storage :b} 2})&quot; &quot;(+ 1 2)&quot; &quot;1&quot; &quot;(require '[cljs.repl :as repl])\n(require '[cljs.repl.node :as node])&quot; &quot;(def env (node/repl-env))\n&quot; &quot;(def opts {:output-dir \&quot;output\&quot;})\n&quot; &quot;(repl/repl* env opts)\n&quot; &quot;3&quot; &quot;(+ 1 2 3)&quot; &quot;(require 'gamma.tools)&quot; &quot;(require 'gamma.test.constructors)&quot; &quot;(in-ns 'gamma.test.constructors)&quot; &quot;(is (= (-&gt;glsl (g/increment f)) \&quot;f++;\&quot;))&quot; &quot;(is false)&quot; &quot;(-&gt;glsl {:tag :variable :id \&quot;f\&quot; :type :float})&quot; &quot;(-&gt;glsl (:tag :literal :value {:tag :variable :id \&quot;f\&quot; :type :float}))&quot; &quot;(-&gt;glsl (:head :literal :value {:tag :variable :id \&quot;f\&quot; :type :float}))&quot; &quot;(-&gt;glsl (gamma.ast/literal {:tag :variable :id \&quot;v\&quot; :type :vec4}))&quot; &quot;(-&gt;glsl (gamma.ast/literal {:tag :variable :name \&quot;v\&quot; :type :vec4}))&quot; &quot;(deftest\n  operators\n  (let [f {:tag :variable :name \&quot;f\&quot; :type :float}\n        v {:tag :variable :name \&quot;v\&quot; :type :vec4}\n        b {:tag :variable :name \&quot;b\&quot; :type :bool}]\n    (is (= (-&gt;glsl (g/aget vec4-variable 0)) \&quot;v[0];\&quot;))\n    ;; selector?\n    (is (= (-&gt;glsl (g/increment f)) \&quot;f++;\&quot;))\n    (is (= (-&gt;glsl (g/decrement f)) \&quot;f--;\&quot;))\n    (is (= (-&gt;glsl (g/pre-increment f)) \&quot;++f;\&quot;))\n    (is (= (-&gt;glsl (g/pre-decrement f)) \&quot;--f;\&quot;))\n    ;(is (= (g/+- t) \&quot;x+-\&quot;))                        ;;?\n    (is (= (-&gt;glsl (g/* f f)) \&quot;f*f;\&quot;))\n    (is (= (-&gt;glsl (g/div f f)) \&quot;f/f;\&quot;))\n    (is (= (-&gt;glsl (g/+ f)) \&quot;f+f;\&quot;))\n    (is (= (-&gt;glsl (g/- f)) \&quot;f-f;\&quot;))\n    (is (= (-&gt;glsl (g/&lt; f)) \&quot;f&lt;f;\&quot;))\n    (is (= (-&gt;glsl (g/&gt; f)) \&quot;f&gt;f;\&quot;))\n    (is (= (-&gt;glsl (g/&lt;= f)) \&quot;f&lt;=f;\&quot;))\n    (is (= (-&gt;glsl (g/&gt;= f)) \&quot;f&gt;=f;\&quot;))\n    (is (= (-&gt;glsl (g/== f)) \&quot;f==f;\&quot;))\n    (is (= (-&gt;glsl (g/!= f)) \&quot;f!=f;\&quot;))\n    ;(is (= (g/conditional-choice f) \&quot;vec4_v--\&quot;))\n    (is (= (-&gt;glsl (g/set f)) \&quot;f=f;\&quot;))\n    (is (= (-&gt;glsl (g/set+ f)) \&quot;f+=f;\&quot;))\n    (is (= (-&gt;glsl (g/set- f)) \&quot;f-=f;\&quot;))\n    (is (= (-&gt;glsl (g/set* f)) \&quot;f*=f;\&quot;))\n    (is (= (-&gt;glsl (g/set-div f)) \&quot;f/=f;\&quot;))\n    ;(is (= (g/constructor f) \&quot;vec4_v--\&quot;))\n    (is (= (-&gt;glsl (g/and b)) \&quot;b&amp;&amp;b;\&quot;))\n    (is (= (-&gt;glsl (g/or b)) \&quot;b||b;\&quot;))\n    (is (= (-&gt;glsl (g/xor b)) \&quot;b&amp;&amp;b;\&quot;))\n    (is (= (-&gt;glsl (g/not b)) \&quot;!b;\&quot;))))&quot; &quot;(deftest\n  operators\n  (let [f {:tag :variable :name \&quot;f\&quot; :type :float}\n        v {:tag :variable :name \&quot;v\&quot; :type :vec4}\n        b {:tag :variable :name \&quot;b\&quot; :type :bool}]\n    (is (= (-&gt;glsl (g/aget vec4-variable 0)) \&quot;v[0];\&quot;))\n    ;; selector?\n    (is (= (-&gt;glsl (g/increment f)) \&quot;f++;\&quot;))\n    (is (= (-&gt;glsl (g/decrement f)) \&quot;f--;\&quot;))\n    (is (= (-&gt;glsl (g/pre-increment f)) \&quot;++f;\&quot;))\n    (is (= (-&gt;glsl (g/pre-decrement f)) \&quot;--f;\&quot;))\n    ;(is (= (g/+- t) \&quot;x+-\&quot;))                        ;;?\n    (is (= (-&gt;glsl (g/* f f)) \&quot;f*f;\&quot;))\n    (is (= (-&gt;glsl (g/div f f)) \&quot;f/f;\&quot;))\n    (is (= (-&gt;glsl (g/+ f f)) \&quot;f+f;\&quot;))\n    (is (= (-&gt;glsl (g/- f f)) \&quot;f-f;\&quot;))\n    (is (= (-&gt;glsl (g/&lt; f f)) \&quot;f&lt;f;\&quot;))\n    (is (= (-&gt;glsl (g/&gt; f f)) \&quot;f&gt;f;\&quot;))\n    (is (= (-&gt;glsl (g/&lt;= f f)) \&quot;f&lt;=f;\&quot;))\n    (is (= (-&gt;glsl (g/&gt;= f f)) \&quot;f&gt;=f;\&quot;))\n    (is (= (-&gt;glsl (g/== f f)) \&quot;f==f;\&quot;))\n    (is (= (-&gt;glsl (g/!= f f)) \&quot;f!=f;\&quot;))\n    ;(is (= (g/conditional-choice f) \&quot;vec4_v--\&quot;))\n    (is (= (-&gt;glsl (g/set f f)) \&quot;f=f;\&quot;))\n    (is (= (-&gt;glsl (g/set+ f f)) \&quot;f+=f;\&quot;))\n    (is (= (-&gt;glsl (g/set- f f)) \&quot;f-=f;\&quot;))\n    (is (= (-&gt;glsl (g/set* f f)) \&quot;f*=f;\&quot;))\n    (is (= (-&gt;glsl (g/set-div f f)) \&quot;f/=f;\&quot;))\n    ;(is (= (g/constructor f) \&quot;vec4_v--\&quot;))\n    (is (= (-&gt;glsl (g/and b b)) \&quot;b&amp;&amp;b;\&quot;))\n    (is (= (-&gt;glsl (g/or b)) \&quot;b||b;\&quot;))\n    (is (= (-&gt;glsl (g/xor b b)) \&quot;b&amp;&amp;b;\&quot;))\n    (is (= (-&gt;glsl (g/not b b)) \&quot;!b;\&quot;))))&quot; &quot;(operators)&quot; &quot;(deftest\n  standard-functions\n  (let [t {:tag :variable :name \&quot;t\&quot; :type :float}\n        f {:tag :variable :name \&quot;f\&quot; :type :float}\n        v2 {:tag :variable :name \&quot;v2\&quot; :type :vec2}\n        v3 {:tag :variable :name \&quot;v3\&quot; :type :vec3}\n        v4 {:tag :variable :name \&quot;v4\&quot; :type :vec4}\n        sampler {:tag :variable :id \&quot;sampler\&quot; :type :sampler2D}]\n    (is (= (-&gt;glsl (g/radians t)) \&quot;radians(t);\&quot;))\n    (is (= (-&gt;glsl (g/degrees t)) \&quot;degrees(t);\&quot;))\n    (is (= (-&gt;glsl (g/sin t)) \&quot;sin(t);\&quot;))\n    (is (= (-&gt;glsl (g/cos t)) \&quot;cos(t);\&quot;))\n    (is (= (-&gt;glsl (g/tan t)) \&quot;tan(t);\&quot;))\n    (is (= (-&gt;glsl (g/asin t)) \&quot;asin(t);\&quot;))\n    (is (= (-&gt;glsl (g/acos t)) \&quot;acos(t);\&quot;))\n    (is (= (-&gt;glsl (g/atan t f2)) \&quot;atan(f,f2);\&quot;))\n    (is (= (-&gt;glsl (g/atan t)) \&quot;atan(t);\&quot;))\n    (is (= (-&gt;glsl (g/power t f2)) \&quot;power(f,f2);\&quot;))\n    (is (= (-&gt;glsl (g/exp t)) \&quot;exp(t);\&quot;))\n    (is (= (-&gt;glsl (g/log t)) \&quot;log(t);\&quot;))\n    (is (= (-&gt;glsl (g/exp2 t)) \&quot;exp2(t);\&quot;))\n    (is (= (-&gt;glsl (g/log2 t)) \&quot;log2(t);\&quot;))\n    (is (= (-&gt;glsl (g/sqrt t)) \&quot;sqrt(t);\&quot;))\n    (is (= (-&gt;glsl (g/inversesqrt t)) \&quot;inversesqrt(t);\&quot;))\n    (is (= (-&gt;glsl (g/abs t)) \&quot;abs(t);\&quot;))\n    (is (= (-&gt;glsl (g/sign t)) \&quot;sign(t);\&quot;))\n    (is (= (-&gt;glsl (g/floor t)) \&quot;floor(t);\&quot;))\n    (is (= (-&gt;glsl (g/ceil t)) \&quot;ceil(t);\&quot;))\n    (is (= (-&gt;glsl (g/fract t)) \&quot;fract(t);\&quot;))\n    (is (= (-&gt;glsl (g/mod t t)) \&quot;mod(t,t);\&quot;))\n    (is (= (-&gt;glsl (g/max t t)) \&quot;max(t,t);\&quot;))\n    (is (= (-&gt;glsl (g/clamp t t t)) \&quot;clamp(t,t,t);\&quot;))\n    (is (= (-&gt;glsl (g/clamp t f f)) \&quot;clamp(t,f,f);\&quot;))\n    (is (= (-&gt;glsl (g/step t t)) \&quot;step(t,t);\&quot;))\n    (is (= (-&gt;glsl (g/step f t)) \&quot;step(f,t);\&quot;))\n    (is (= (-&gt;glsl (g/smoothstep t t t)) \&quot;smoothstep(t,t,t);\&quot;))\n    (is (= (-&gt;glsl (g/smoothstep f f t)) \&quot;smoothstep(f,f,t);\&quot;))\n    (is (= (-&gt;glsl (g/length t)) \&quot;length(t);\&quot;))\n    (is (= (-&gt;glsl (g/distance t t)) \&quot;distance(t,t);\&quot;))\n    (is (= (-&gt;glsl (g/dot t t)) \&quot;dot(t,t);\&quot;))\n    (is (= (-&gt;glsl (g/cross v3 v3)) \&quot;cross(v3,v3);\&quot;))\n    (is (= (-&gt;glsl (g/normalize t)) \&quot;normalize(t);\&quot;))\n    (is (= (-&gt;glsl (g/faceforward t t t)) \&quot;faceforward(t,t,t);\&quot;))\n    (is (= (-&gt;glsl (g/reflect t t)) \&quot;reflect(t,t);\&quot;))\n    (is (= (-&gt;glsl (g/refract t t f)) \&quot;refract(t,t,f);\&quot;))\n    (is (= (-&gt;glsl (g/texture2DLod sampler v2 f)) \&quot;texture2DLod(sampler,v2,f);\&quot;))\n    (is (= (-&gt;glsl (g/texture2DProjLod sampler v3 f)) \&quot;texture2DProjLod(sampler,v3,f);\&quot;))\n    (is (= (-&gt;glsl (g/texture2DProjLod sampler v4 f)) \&quot;texture2DProjLod(sampler,v4,f);\&quot;))\n    (is (= (-&gt;glsl (g/textureCubeLod sampler v4 f)) \&quot;textureCubeLod(sampler,v4,f);\&quot;))\n    (is (= (-&gt;glsl (g/texture2D sampler v2 f)) \&quot;texture2D(sampler,v2,f);\&quot;))\n    (is (= (-&gt;glsl (g/texture2DProj sampler v3 f)) \&quot;texture2DProj(sampler,v3,f);\&quot;))\n    (is (= (-&gt;glsl (g/texture2DProj sampler v4 f)) \&quot;texture2DProj(sampler,v4,f);\&quot;))\n    (is (= (-&gt;glsl (g/textureCube sampler v3 f)) \&quot;textureCube(sampler,v3,f);\&quot;))\n    (is (= (-&gt;glsl (g/texture2D sampler v2)) \&quot;texture2D(sampler,v2);\&quot;))\n    (is (= (-&gt;glsl (g/texture2DProj sampler v3 f)) \&quot;texture2DProj(sampler,v3,f);\&quot;))\n    (is (= (-&gt;glsl (g/texture2DProj sampler v4 f)) \&quot;texture2DProj(sampler,v4,f);\&quot;))\n    (is (= (-&gt;glsl (g/textureCube sampler v3)) \&quot;textureCube(sampler,v3);\&quot;))))&quot; &quot;(standard-functions)&quot; &quot;(g/sin 1)&quot; &quot;(g/sin \&quot;a\&quot;)&quot; &quot;(g/sin true)&quot; &quot;(g/attribute \&quot;my_Attribute\&quot; :float)&quot; &quot;(def code-fragment\n  (let [a (g/attribute \&quot;my_Attribute\&quot; :float)]\n    (g/sin a)))&quot; &quot;(require '[gamma.tools :as tools])&quot; &quot;(tools/glsl-string (g/sin 1))&quot; &quot;(g/cos (g/sin (g/if (g/&lt; 1 a) 2 3)))&quot; &quot;(def code-fragment\n  (let [a (g/attribute \&quot;my_Attribute\&quot; :float)]\n    (g/cos (g/sin (g/if (g/&lt; 1 a) 2 3)))))&quot; &quot;(tools/glsl-string code-fragment)&quot; &quot;(println (tools/glsl-string code-fragment))&quot; &quot;(g/+ 1 2)&quot; &quot;4&quot; &quot;(require '[gamma.api :as g])&quot;], :remote []}}</component>
</project>