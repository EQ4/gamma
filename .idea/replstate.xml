<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1424297960136">{:repl-history {:ide [], :local [&quot;(fipp.printer/pprint-document\n    (emit db (db (first (:body (:root db)))))\n     {:width 10})&quot; &quot;(use 'gamma.emit.operator :reload)&quot; &quot;(def db\n    (flatten-ast (let [x (term :abs 1)]\n                   (term :&gt;\n                         (term :floor x)\n                         (term :increment (term :ceil x))))))&quot; &quot;(fipp.printer/pprint-document\n    (emit db (db (first (:body (:root db)))))\n    {:width 15})&quot; &quot;(use 'gamma.emit.statement :reload)&quot; &quot;(def db\n    (flatten-ast (let [x (term :abs 1)]\n                   (term :block\n                         x\n                         (term :floor x)\n                         (term :increment (term :ceil x))))))&quot; &quot;(use 'gamma.emit.emit :reload)&quot; &quot;(use 'gamma.emit.tag :reload)&quot; &quot;(def db\n    (flatten-ast (term :set\n                       (term :literal {:tag :variable :id 1})\n                       (term :floor 1)\n                       )))&quot; &quot;(def db\n    (flatten-ast (term :set\n                       {:head :literal :value {:tag :variable :id 1}}\n                       \n                       (term :floor 1)\n                       )))&quot; &quot;(fipp.printer/pprint-document\n    (emit db (db (first (:body (:root db)))))\n    {:width 10})&quot; &quot;(in-ns 'user)&quot; &quot;(use 'gamma.compiler.lift-assignments :reload)&quot; &quot;use &quot; &quot;(use 'gamma.emit.emit)&quot; &quot;(require 'gamma.compiler.lift-assignments)&quot; &quot;(in-ns 'gamma.compiler.lift-assignments)&quot; &quot;(use 'gamma.compiler.print)&quot; &quot;(def db2\n    (flatten-ast (let [x (term :foo 1)]\n                   (term :bar\n                         (term :baz x)\n                         (term :baz x)))))&quot; &quot;(def d2\n    (transform {:root {:source-id :root :id :root}}\n               (separate-usages (bubble-terms db2) {} #{})))&quot; &quot;(use 'gamma.compiler.print :reload)&quot; &quot;(print-ast2 d2\n             (fn [x db] [(:id (:id x)) (mapv :id (:shared x))]) 30)&quot; &quot;(print-ast d2\n             (fn [x db] [(:id (:id x)) (mapv :id (:shared x))]) 30)&quot; &quot;(def d3\n    (transform d2\n               (lift-assignments :root)))&quot; &quot;(def test1\n    (let [c1 (term :foo 1)\n         c2 (g/if true (term :bar c1 c1) false)]\n      (bubble-terms (flatten-ast c2))))&quot; &quot;(print-ast data3\n             (fn printer [x db]\n               [:group \&quot;{\&quot;\n                (str (:id (:id x))) \&quot; \&quot;\n                (if (= :literal (:head x))\n                  (str \&quot;val:\&quot; (:value x))\n                  (map #(gamma.compiler.print/ast-doc db % printer)\n                       (:assignments x)))\n                \&quot;}\&quot;\n                ]) 30)&quot; &quot;(print-ast test3\n             (fn [x db] [(:id (:id x)) (mapv :id (:assignments x))]) 30)&quot; &quot;x &quot; &quot;test3 &quot; &quot;gamma.compiler.lift-assignments/test3 &quot; &quot;(print-ast gamma.compiler.lift-assignments/test3\n             (fn [x db] [(:id (:id x)) (mapv :id (:assignments x))]) 30)&quot; &quot;(ast-doc2 gamma.compiler.lift-assignments/test3 :root [:body])&quot; &quot;(fipp.printer/pprint-document\n    (ast-doc2 gamma.compiler.lift-assignments/test3 :root [:body])\n    {:width 40})&quot; &quot;(fipp.printer/pprint-document\n    (ast-doc2 gamma.compiler.lift-assignments/test3 :root [:body])\n    {:width 30})&quot; &quot;(emit\n    (ast-doc2 gamma.compiler.lift-assignments/test3 :root [:body]))&quot; &quot;(gmma.emit.emit/emit\n    gamma.compiler.lift-assignments/test3 ( gamma.compiler.lift-assignments/test3 :root))&quot; &quot;(require 'gamma.emit.statement)&quot; &quot;(clojure.stacktrace/e)&quot; &quot;(defmethod emit :if [x db]\n  (let [[test then else] (body x)]\n\n    (str \&quot;if(\&quot; (emit test) \&quot;)\&quot;\n         \&quot;{\&quot; (emit then) \&quot;}\&quot;)))&quot; &quot;(defmethod emit :if [x db]\n  (let [[test then else] (body x)]\n\n    (str \&quot;if(\&quot; (emit db (db test)) \&quot;)\&quot;\n         \&quot;{\&quot; (emit db (db then)) \&quot;}\&quot;)))&quot; &quot;(defmethod emit :if [x db]\n  (let [[test then else] (body x)]\n    (println [test then])\n    (str \&quot;if(\&quot; (emit db (db test)) \&quot;)\&quot;\n         \&quot;{\&quot; (emit db (db then)) \&quot;}\&quot;)))&quot; &quot;(defmethod emit :if [db x]\n  (let [[test then else] (body x)]\n    (println [test then])\n    (str \&quot;if(\&quot; (emit db (db test)) \&quot;)\&quot;\n         \&quot;{\&quot; (emit db (db then)) \&quot;}\&quot;)))&quot; &quot;(def db2\n    (flatten-ast (let [x (term :clamp 1)]\n                   (term :sin\n                         (term :cos x)\n                         (term :cos x)))))&quot; &quot;(def test1\n    (let [c1 (term :clamp 1)\n         c2 (g/if true (term :sin c1 c1) false)]\n      (bubble-terms (flatten-ast c2))))&quot; &quot;(def test2\n        (transform  {:root {:source-id :root :id :root}}\n                    (separate-usages test1 {} #{})))&quot; &quot;(def test3\n    (transform test2 (lift-assignments :root)))&quot; &quot;(require 'gamma.emit.function)&quot; &quot;(gamma.emit.emit/emit\n    gamma.compiler.lift-assignments/test3 ( gamma.compiler.lift-assignments/test3 :root))&quot; &quot;(defmethod emit :if [db x]\n  (let [[test then else] (body x)]\n    [:group \&quot;if(\&quot; (emit db (db test)) \&quot;)\&quot; \&quot;{\&quot; (emit db (db then)) \&quot;}\&quot;]))&quot; &quot;(gamma.emit.emit/emit\n  gamma.compiler.lift-assignments/test3 ( gamma.compiler.lift-assignments/test3 :root))\n&quot; &quot;(defmethod emit :variable [db x]\n  (str \&quot;v\&quot; (:id x)))&quot; &quot;(fipp.printer/pprint-document\n    (gamma.emit.emit/emit\n      gamma.compiler.lift-assignments/test3 (gamma.compiler.lift-assignments/test3 :root))\n    {:width 30})&quot; &quot;[[db ops]\n             (do\n               ;(println [(f 1) (f 0)])\n               ((f 1) db (f 0)))]&quot; &quot;(ns gamma.compiler.core\n  (:use [gamma.compiler.common\n         :only [get-element map-path location-conj]])\n  (:use [gamma.ast :only [id? term]]\n        [gamma.compiler.flatten-ast :only [flatten-ast]])\n  (:require [fipp.edn :refer (pprint) :rename {pprint fipp}]\n            fipp.printer))&quot; &quot;(defn push-ops [db ops location stack]\n  (reduce\n    (fn [s o]\n      (if (vector? o)\n        (conj s [(location-conj db location (first o)) (second o)])\n        (conj s [location o])))\n    stack\n    (reverse ops)))&quot; &quot;(use 'clojure.core)&quot; &quot;(use 'gamma.compiler.lift-assignments)&quot; &quot;(use 'gamma.compiler.insert-assignments)&quot; &quot;(in-ns 'gamma.compiler.insert-assignments)&quot; &quot;(require '[gamma.api :as g] )&quot; &quot;(use '[gamma.compiler.lift-assignments :only [lift-assignments]])&quot; &quot;(use '[gamma.compiler.insert-variables :only [insert-variables]])&quot; &quot;(def data1 (let [c1 (term :foo 1)\n                  c2 (g/if true (term :bar c1 c1) false)]\n              (bubble-terms (flatten-ast c2))))&quot; &quot;(use 'gamma.compiler.separate-usages\n       '[gamma.ast :only [id? term]]\n       '[gamma.compiler.flatten-ast :only [flatten-ast]]\n       'clojure.stacktrace\n       'gamma.ast\n       'gamma.compiler.core\n       'gamma.compiler.bubble-term\n       'gamma.compiler.print\n       )&quot; &quot;(def data2\n    (-&gt; (transform {:root {:source-id :root :id :root}}\n                   (separate-usages test {} #{}))\n        (transform  (lift-assignments :root))\n        (transform  (insert-variables #{}))\n        ))&quot; &quot;(use 'gamma.compiler.core)&quot; &quot;gamma.compiler.core/transform &quot; &quot;(in-ns gamma.compiler.core)&quot; &quot;(in-ns 'gamma.compiler.core)&quot; &quot;transform&quot; &quot;(defmethod emit :variable [db x]\n  (str \&quot;v\&quot; (:id (:id x))))&quot; &quot;(use 'gamma.emit.emit\n       'gamma.emit.function\n       'gamma.emit.operator\n       'gamma.emit.statement\n       'gamma.emit.tag)&quot; &quot;x&quot; &quot;(def y 1)&quot; &quot;y&quot; &quot;(def z 1)&quot; &quot;(def xy 1)&quot; &quot;(use 'gamma.ast)\n&quot; &quot;(def x 1)&quot; &quot;(let [x 1] x)\n&quot; &quot;(use '[gamma.api :as g])&quot; &quot;(use 'gamma.emit.emit\n     'gamma.emit.function\n     'gamma.emit.operator\n     'gamma.emit.statement\n     'gamma.emit.tag)&quot; &quot;(use 'gamma.ast)&quot; &quot;1&quot; &quot;(let [x 1] x\n           )&quot; &quot;(let [x 1] x)&quot; &quot;(def data1 (let [c1 (term :foo 1)\n                 c2 (g/if true (term :bar c1 c1) false)]\n             (bubble-terms (flatten-ast c2))))&quot; &quot;(ns gamma.examples\n  (:require\n    [gamma.api :as g]\n    gamma.emit.function\n    gamma.emit.operator\n    gamma.emit.statement\n    gamma.emit.tag\n    gamma.ast\n    gamma.emit.emit))&quot; &quot;g/if&quot; &quot;(def data1 (let [c1 (g/term :foo 1)\n                 c2 (g/if true (term :bar c1 c1) false)]\n             (bubble-terms (flatten-ast c2))))&quot; &quot;(ns gamma.examples\n  (:require\n    [gamma.api :as g]\n    gamma.emit.function\n    gamma.emit.operator\n    gamma.emit.statement\n    gamma.emit.tag\n    [gamma.ast :as ast]\n    gamma.emit.emit))&quot; &quot;(ns gamma.examples\n  (:require\n    [gamma.api :as g]\n    gamma.emit.function\n    gamma.emit.operator\n    gamma.emit.statement\n    gamma.emit.tag\n    [gamma.ast :as ast]\n    gamma.emit.emit\n    [gamma.compiler.flatten-ast :as fa]\n    [gamma.compiler.bubble-term])\n  )&quot; &quot;(def data1 (let [c1 (ast/term :foo 1)\n                 c2 (g/if true (ast/term :bar c1 c1) false)]\n             (gamma.compiler.bubble-term/bubble-terms (fa/flatten-ast c2))))&quot; &quot;(ns gamma.examples\n  (:require\n    [gamma.api :as g]\n    gamma.emit.emit\n    gamma.emit.function\n    gamma.emit.operator\n    gamma.emit.statement\n    gamma.emit.tag\n    [gamma.ast :as ast])\n  (:use\n    [gamma.compiler.flatten-ast :only [flatten-ast]]\n    [gamma.compiler.bubble-term :only [bubble-terms]]\n    [gamma.compiler.insert-assignments :only [insert-assignments]]\n    [gamma.compiler.lift-assignments :only [lift-assignments]]\n    [gamma.compiler.separate-usages :only [separate-usages]]\n    [gamma.compiler.insert-variables :only [insert-variables]]\n    [gamma.compiler.core :only [transform]]))&quot; &quot;(def data1 (let [c1 (ast/term :foo 1)\n                 c2 (g/if true (ast/term :bar c1 c1) false)]\n             (bubble-terms (flatten-ast c2))))&quot; &quot;(def data2\n  (-&gt; (transform {:root {:source-id :root :id :root}}\n                 (separate-usages data1 {} #{}))\n      (transform  (lift-assignments :root))\n      (transform  (insert-variables #{}))\n      ))&quot; &quot;(def data3 (transform data2 (insert-assignments)))&quot; &quot;data3&quot; &quot;(defn foo [x]\n  (let [y (+ x 1)]\n    (+ y 2)))&quot; &quot;(foo 2)&quot; &quot;2&quot;], :remote []}}</component>
</project>

