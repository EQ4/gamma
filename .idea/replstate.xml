<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1423868020811">{:repl-history {:ide [], :local [&quot;(defn ast-doc2 [db node-id paths]\n  (let [x (if (or (= :root node-id) (id? node-id)) (db node-id) node-id)]\n    [:group\n     (pr-str (:head x))\n     \&quot;[\&quot;\n     (let [i (:id x)] (if (= :root i) \&quot;:root\&quot; (str (:id i))))\n     \&quot;]\&quot;\n     \&quot;{\&quot;\n     [:line \&quot;\&quot;]\n     \&quot;:body \&quot;\n     (helper db paths (:body x))\n\n\n     \&quot;}\&quot;]))&quot; &quot;(defn ast-doc2 [db node-id paths]\n  (let [x #spy/d (if (or (= :root node-id) (id? node-id)) (db node-id) node-id)]\n    [:group\n     (pr-str (:head x))\n     \&quot;[\&quot;\n     (let [i (:id x)] (if (= :root i) \&quot;:root\&quot; (str (:id i))))\n     \&quot;]\&quot;\n     \&quot;{\&quot;\n     [:line \&quot;\&quot;]\n     \&quot;:body \&quot;\n     (helper db paths (:body x))\n\n\n     \&quot;}\&quot;]))&quot; &quot;(defn print-ast2 [x  w]\n  (fipp.printer/pprint-document\n    (ast-doc2\n      x\n      :root\n      [:body]) {:width w}))&quot; &quot;(:root data3)&quot; &quot;data2 &quot; &quot;(def data1 (let [c1 (term :foo 1)\n                  c2 (g/if true (term :bar c1 c1) false)]\n              (bubble-terms (flatten-ast c2))))&quot; &quot;(def data2\n    (-&gt; (transform {:root {:source-id :root :id :root}}\n                   (separate-usages test {} #{}))\n        (transform  (lift-assignments :root))\n        (transform  (insert-variables #{}))\n        ))&quot; &quot;(def data3 (transform data2 (insert-assignments)))&quot; &quot;(print-ast2 data3 [:body] 30)&quot; &quot;(defn ast-doc2 [db node-id paths]\n  (let [x  (if (or (= :root node-id) (id? node-id)) (db node-id) node-id)]\n    [:group\n     (pr-str (:head x))\n     \&quot;[\&quot;\n     (let [i (:id x)] (if (= :root i) \&quot;:root\&quot; (str (:id i))))\n     \&quot;]\&quot;\n     \&quot;{\&quot;\n     [:line \&quot;\&quot;]\n     \&quot;:body \&quot;\n     (helper db paths (:body x))\n\n\n     \&quot;}\&quot;]))&quot; &quot;data3 &quot; &quot;(defn ast-doc2 [db node-id paths]\n  (let [x  (if (or (= :root node-id) (id? node-id)) (db node-id) node-id)]\n    [:group\n     (pr-str (:head x))\n     \&quot;[\&quot;\n     (let [i (:id x)] (if (= :root i) \&quot;:root\&quot; (str (:id i))))\n     \&quot;]\&quot;\n     \&quot;{\&quot;\n     [:line \&quot;\&quot;]\n     [:nest 2 \&quot;:body \&quot; (helper db paths (:body x))]\n     \n\n\n     \&quot;}\&quot;]))&quot; &quot;(print-ast2 data3  30)&quot; &quot;(defn ast-doc2 [db node-id paths]\n  (let [x  (if (or (= :root node-id) (id? node-id)) (db node-id) node-id)]\n    [:group\n     (pr-str (:head x))\n     \&quot;(\&quot;\n     (let [i (:id x)] (if (= :root i) \&quot;:root\&quot; (str (:id i))))\n     \&quot;)\&quot;\n     \&quot;{\&quot;\n     [:line \&quot;\&quot;]\n     [:nest 2 \&quot;:body \&quot; (helper db paths (:body x))]\n\n\n\n     \&quot;}\&quot;]))&quot; &quot;(defn ast-doc2 [db node-id paths]\n  (let [x  (if (or (= :root node-id) (id? node-id)) (db node-id) node-id)]\n    [:group\n     (pr-str (:head x))\n     \&quot;(\&quot;\n     (let [i (:id x)] (if (= :root i) \&quot;:root\&quot; (str (:id i))))\n     \&quot;)\&quot;\n     \&quot;{\&quot;\n     [:line \&quot;\&quot;]\n     [:nest 2 \&quot;:assignments \&quot; (helper db paths (:assignments x))]\n     [:nest 2 \&quot;:body \&quot; (helper db paths (:body x))]\n     \n\n\n\n     \&quot;}\&quot;]))&quot; &quot;(defn ast-doc2 [db node-id paths]\n  (let [x  (if (or (= :root node-id) (id? node-id)) (db node-id) node-id)]\n    [:group\n     (pr-str (:head x))\n     \&quot;(\&quot;\n     (let [i (:id x)] (if (= :root i) \&quot;:root\&quot; (str (:id i))))\n     \&quot;)\&quot;\n     \&quot;{\&quot;\n     [:line \&quot;\&quot;]\n     [:nest 2 \&quot;:assignments \&quot;  [:line \&quot;\&quot;] (helper db paths (:assignments x))]\n     [:nest 2 \&quot;:body \&quot; [:line \&quot;\&quot;] (helper db paths (:body x))]\n     \n\n\n\n     \&quot;}\&quot;]))&quot; &quot;(defn ast-doc2 [db node-id paths]\n  (let [x  (if (or (= :root node-id) (id? node-id)) (db node-id) node-id)]\n    [:group\n     (pr-str (:head x))\n     \&quot;(\&quot;\n     (let [i (:id x)] (if (= :root i) \&quot;:root\&quot; (str (:id i))))\n     \&quot;)\&quot;\n     (if (= :literal (:head x))\n       (pr-str (dissoc x :id :head))\n       [:span\n        \&quot;{\&quot;\n        [:line \&quot;\&quot;]\n        [:nest 2 \&quot;:assignments \&quot;  [:line \&quot;\&quot;] (helper db paths (:assignments x))]\n        [:nest 2 \&quot;:body \&quot; [:line \&quot;\&quot;] (helper db paths (:body x))]\n        \&quot;}\&quot;]\n       )\n     ]))&quot; &quot;(defn ast-doc2 [db node-id paths]\n  (let [x  (if (or (= :root node-id) (id? node-id)) (db node-id) node-id)]\n    [:group\n     (pr-str (:head x))\n     \&quot;(\&quot;\n     (let [i (:id x)] (if (= :root i) \&quot;:root\&quot; (str (:id i))))\n     \&quot;)\&quot;\n     (if (= :literal (:head x))\n       (pr-str (select-keys x [:value]))\n       [:span\n        \&quot;{\&quot;\n        [:line \&quot;\&quot;]\n        [:nest 2 \&quot;:assignments \&quot;  [:line \&quot;\&quot;] (helper db paths (:assignments x))]\n        [:nest 2 \&quot;:body \&quot; [:line \&quot;\&quot;] (helper db paths (:body x))]\n        \&quot;}\&quot;]\n       )\n     ]))&quot; &quot;(defn ast-doc2 [db node-id paths]\n  (let [x  (if (or (= :root node-id) (id? node-id)) (db node-id) node-id)]\n    [:group\n     (pr-str (:head x))\n     \&quot;(\&quot;\n     (let [i (:id x)] (if (= :root i) \&quot;:root\&quot; (str (:id i))))\n     \&quot;)\&quot;\n     (if (= :literal (:head x))\n       (pr-str (select-keys x [:value]))\n       [:span\n        \&quot;{\&quot;\n        [:line \&quot;\&quot;]\n        (if-let [y (:assignments x)] \n          [:nest 2 \&quot;:assignments \&quot; [:line \&quot;\&quot;] (helper db paths y)]\n          [:span \&quot;\&quot;])\n        [:nest 2 \&quot;:body \&quot; [:line \&quot;\&quot;] (helper db paths (:body x))]\n        \&quot;}\&quot;]\n       )\n     ]))&quot; &quot;(print-ast2 data3 30)&quot; &quot;(def db\n    (flatten-ast (let [x (term :foo 1)]\n                   (term :bar\n                         (term :baz x)\n                         (term :baz x)))))&quot; &quot;(:root db)&quot; &quot;(first (:body (:root db)))&quot; &quot;(db (first (:body (:root db))))&quot; &quot;(defmethod emit :literal [db x] (emit db (:value x)))&quot; &quot;(require '[fipp.edn :refer (pprint) :rename {pprint fipp}]\n   fipp.printer)&quot; &quot;(fipp.printer/pprint-document\n    (emit db (db (first (:body (:root db)))))\n     {:width 20})&quot; &quot;(fipp.printer/pprint-document\n    (emit db (db (first (:body (:root db)))))\n     {:width 15})&quot; &quot;(use 'gamma.emit.operator)&quot; &quot;(def db\n    (flatten-ast (let [x (term :abs 1)]\n                   (term :&gt;\n                         (term :floor x)\n                         (term :ceil x)))))&quot; &quot;(def db\n    (flatten-ast (let [x (term :abs 1)]\n                   (term :&gt;\n                         (term :floor x)\n                         (term :inc (term :ceil x))))))&quot; &quot;(fipp.printer/pprint-document\n    [:group \&quot;a\&quot; [:line] \&quot;b\&quot;]\n    {:width 15})&quot; &quot;(fipp.printer/pprint-document\n    [:group \&quot;a\&quot; [:break] \&quot;b\&quot;]\n    {:width 15})&quot; &quot;(fipp.printer/pprint-document\n    [:group \&quot;a\&quot; :break \&quot;b\&quot;]\n    {:width 15})&quot; &quot;(ns gamma.emit.emit\n  (:use [gamma.ast :only [term -&gt;Term head body]]))&quot; &quot;(in-ns 'gamma.emit.emit)&quot; &quot;(use '[gamma.ast :only [id? term]]\n       '[gamma.compiler.flatten-ast :only [flatten-ast]])&quot; &quot;(def db\n    (flatten-ast (let [x (term :abs 1)]\n                   (term :mod\n                         (term :floor x)\n                         (term :ceil x)))))&quot; &quot;(use 'gamma.emit.function)&quot; &quot;(emit db (db (first (:body (:root db)))))&quot; &quot;(require '[fipp.edn :refer (pprint) :rename {pprint fipp}]\n   'fipp.printer)&quot; &quot;(fipp.printer/pprint-document\n    (emit db (db (first (:body (:root db)))))\n     {:width 10})&quot; &quot;(use 'gamma.emit.operator :reload)&quot; &quot;(def db\n    (flatten-ast (let [x (term :abs 1)]\n                   (term :&gt;\n                         (term :floor x)\n                         (term :increment (term :ceil x))))))&quot; &quot;(fipp.printer/pprint-document\n    (emit db (db (first (:body (:root db)))))\n    {:width 15})&quot; &quot;(use 'gamma.emit.statement :reload)&quot; &quot;(def db\n    (flatten-ast (let [x (term :abs 1)]\n                   (term :block\n                         x\n                         (term :floor x)\n                         (term :increment (term :ceil x))))))&quot; &quot;(use 'gamma.emit.emit :reload)&quot; &quot;(use 'gamma.emit.tag :reload)&quot; &quot;(def db\n    (flatten-ast (term :set\n                       (term :literal {:tag :variable :id 1})\n                       (term :floor 1)\n                       )))&quot; &quot;(def db\n    (flatten-ast (term :set\n                       {:head :literal :value {:tag :variable :id 1}}\n                       \n                       (term :floor 1)\n                       )))&quot; &quot;(fipp.printer/pprint-document\n    (emit db (db (first (:body (:root db)))))\n    {:width 10})&quot; &quot;(in-ns 'user)&quot; &quot;(use 'gamma.compiler.lift-assignments :reload)&quot; &quot;1&quot; &quot;(use 'gamma.compiler.lift-assignments)&quot; &quot;use &quot; &quot;(use 'gamma.compiler.core)&quot; &quot;(in-ns 'gamma.compiler.core)&quot; &quot;(use 'gamma.emit.emit)&quot; &quot;(require 'gamma.compiler.lift-assignments)&quot; &quot;(in-ns 'gamma.compiler.lift-assignments)&quot; &quot;(use 'gamma.compiler.separate-usages\n       '[gamma.ast :only [id? term]]\n       '[gamma.compiler.flatten-ast :only [flatten-ast]]\n       'clojure.stacktrace\n       'gamma.ast\n       'gamma.compiler.core\n       'gamma.compiler.bubble-term\n       'gamma.compiler.print\n       )&quot; &quot;(use 'gamma.compiler.print)&quot; &quot;(def db2\n    (flatten-ast (let [x (term :foo 1)]\n                   (term :bar\n                         (term :baz x)\n                         (term :baz x)))))&quot; &quot;(def d2\n    (transform {:root {:source-id :root :id :root}}\n               (separate-usages (bubble-terms db2) {} #{})))&quot; &quot;(use 'gamma.compiler.print :reload)&quot; &quot;(print-ast2 d2\n             (fn [x db] [(:id (:id x)) (mapv :id (:shared x))]) 30)&quot; &quot;(print-ast d2\n             (fn [x db] [(:id (:id x)) (mapv :id (:shared x))]) 30)&quot; &quot;(def d3\n    (transform d2\n               (lift-assignments :root)))&quot; &quot;(require '[gamma.api :as g] )&quot; &quot;(def test1\n    (let [c1 (term :foo 1)\n         c2 (g/if true (term :bar c1 c1) false)]\n      (bubble-terms (flatten-ast c2))))&quot; &quot;(print-ast data3\n             (fn printer [x db]\n               [:group \&quot;{\&quot;\n                (str (:id (:id x))) \&quot; \&quot;\n                (if (= :literal (:head x))\n                  (str \&quot;val:\&quot; (:value x))\n                  (map #(gamma.compiler.print/ast-doc db % printer)\n                       (:assignments x)))\n                \&quot;}\&quot;\n                ]) 30)&quot; &quot;(print-ast test3\n             (fn [x db] [(:id (:id x)) (mapv :id (:assignments x))]) 30)&quot; &quot;(def x 1)&quot; &quot;x &quot; &quot;test3 &quot; &quot;gamma.compiler.lift-assignments/test3 &quot; &quot;(print-ast gamma.compiler.lift-assignments/test3\n             (fn [x db] [(:id (:id x)) (mapv :id (:assignments x))]) 30)&quot; &quot;(ast-doc2 gamma.compiler.lift-assignments/test3 :root [:body])&quot; &quot;(fipp.printer/pprint-document\n    (ast-doc2 gamma.compiler.lift-assignments/test3 :root [:body])\n    {:width 40})&quot; &quot;(fipp.printer/pprint-document\n    (ast-doc2 gamma.compiler.lift-assignments/test3 :root [:body])\n    {:width 30})&quot; &quot;(emit\n    (ast-doc2 gamma.compiler.lift-assignments/test3 :root [:body]))&quot; &quot;(gmma.emit.emit/emit\n    gamma.compiler.lift-assignments/test3 ( gamma.compiler.lift-assignments/test3 :root))&quot; &quot;(require 'gamma.emit.statement)&quot; &quot;(clojure.stacktrace/e)&quot; &quot;(defmethod emit :if [x db]\n  (let [[test then else] (body x)]\n\n    (str \&quot;if(\&quot; (emit test) \&quot;)\&quot;\n         \&quot;{\&quot; (emit then) \&quot;}\&quot;)))&quot; &quot;(defmethod emit :if [x db]\n  (let [[test then else] (body x)]\n\n    (str \&quot;if(\&quot; (emit db (db test)) \&quot;)\&quot;\n         \&quot;{\&quot; (emit db (db then)) \&quot;}\&quot;)))&quot; &quot;(defmethod emit :if [x db]\n  (let [[test then else] (body x)]\n    (println [test then])\n    (str \&quot;if(\&quot; (emit db (db test)) \&quot;)\&quot;\n         \&quot;{\&quot; (emit db (db then)) \&quot;}\&quot;)))&quot; &quot;(defmethod emit :if [db x]\n  (let [[test then else] (body x)]\n    (println [test then])\n    (str \&quot;if(\&quot; (emit db (db test)) \&quot;)\&quot;\n         \&quot;{\&quot; (emit db (db then)) \&quot;}\&quot;)))&quot; &quot;(def db2\n    (flatten-ast (let [x (term :clamp 1)]\n                   (term :sin\n                         (term :cos x)\n                         (term :cos x)))))&quot; &quot;(def test1\n    (let [c1 (term :clamp 1)\n         c2 (g/if true (term :sin c1 c1) false)]\n      (bubble-terms (flatten-ast c2))))&quot; &quot;(def test2\n        (transform  {:root {:source-id :root :id :root}}\n                    (separate-usages test1 {} #{})))&quot; &quot;(def test3\n    (transform test2 (lift-assignments :root)))&quot; &quot;(require 'gamma.emit.function)&quot; &quot;(gamma.emit.emit/emit\n    gamma.compiler.lift-assignments/test3 ( gamma.compiler.lift-assignments/test3 :root))&quot; &quot;(defmethod emit :if [db x]\n  (let [[test then else] (body x)]\n    [:group \&quot;if(\&quot; (emit db (db test)) \&quot;)\&quot; \&quot;{\&quot; (emit db (db then)) \&quot;}\&quot;]))&quot; &quot;(gamma.emit.emit/emit\n  gamma.compiler.lift-assignments/test3 ( gamma.compiler.lift-assignments/test3 :root))\n&quot; &quot;(defmethod emit :variable [db x]\n  (str \&quot;v\&quot; (:id x)))&quot; &quot;(fipp.printer/pprint-document\n    (gamma.emit.emit/emit\n      gamma.compiler.lift-assignments/test3 (gamma.compiler.lift-assignments/test3 :root))\n    {:width 30})&quot; &quot;(use 'gamma.compiler.insert-assignments)&quot;], :remote []}}</component>
</project>

