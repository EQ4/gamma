;; Analyzed by ClojureScript 0.0-3208
{:defs {each {:protocol-inline nil, :meta {:top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}, :arglists (quote ([f] [f coll])), :doc "Applies f to each item in coll, returns nil", :end-column 17, :end-line 34, :column 13, :line 34, :file "/Users/kovasb/repo/gamma/resources/public/js/out/transduce/reducers.cljs"}, :name transduce.reducers/each, :variadic false, :file "resources/public/js/out/transduce/reducers.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 34, :end-line 34, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f coll]), :doc "Applies f to each item in coll, returns nil", :test true}, mapcat-state {:protocol-inline nil, :meta {:top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f init] [f init coll]), :arglists ([f init] [f init coll]), :arglists-meta (nil nil)}, :arglists (quote ([f init] [f init coll])), :doc "Like mapcat, but threads a state through the sequence of transformations.\n  For each x in coll, f is applied to [state x] and should return [state' xs].\n  The result is the concatenation of each returned xs.", :end-column 25, :end-line 19, :column 13, :line 19, :file "/Users/kovasb/repo/gamma/resources/public/js/out/transduce/reducers.cljs"}, :name transduce.reducers/mapcat-state, :variadic false, :file "resources/public/js/out/transduce/reducers.cljs", :end-column 25, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f init] [f init coll]), :arglists ([f init] [f init coll]), :arglists-meta (nil nil)}, :method-params ([f init] [f init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 19, :end-line 19, :max-fixed-arity 3, :fn-var true, :arglists ([f init] [f init coll]), :doc "Like mapcat, but threads a state through the sequence of transformations.\n  For each x in coll, f is applied to [state x] and should return [state' xs].\n  The result is the concatenation of each returned xs.", :test true}, map-state {:protocol-inline nil, :meta {:top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f init] [f init coll]), :arglists ([f init] [f init coll]), :arglists-meta (nil nil)}, :arglists (quote ([f init] [f init coll])), :doc "Like map, but threads a state through the sequence of transformations.\n  For each x in coll, f is applied to [state x] and should return [state' x'].\n  The first invocation of f uses init as the state.", :end-column 22, :end-line 6, :column 13, :line 6, :file "/Users/kovasb/repo/gamma/resources/public/js/out/transduce/reducers.cljs"}, :name transduce.reducers/map-state, :variadic false, :file "resources/public/js/out/transduce/reducers.cljs", :end-column 22, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f init] [f init coll]), :arglists ([f init] [f init coll]), :arglists-meta (nil nil)}, :method-params ([f init] [f init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6, :end-line 6, :max-fixed-arity 3, :fn-var true, :arglists ([f init] [f init coll]), :doc "Like map, but threads a state through the sequence of transformations.\n  For each x in coll, f is applied to [state x] and should return [state' x'].\n  The first invocation of f uses init as the state.", :test true}}, :imports nil, :requires {clojure.core.reducers clojure.core.reducers, r clojure.core.reducers}, :uses nil, :require-macros {transduce.macros transduce.macros}, :use-macros {defcurried transduce.macros}, :excludes #{}, :doc "Provides reducers support for State Transducers", :name transduce.reducers}